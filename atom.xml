<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TickTock Ideas</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charleywu.com/"/>
  <updated>2017-12-18T03:47:30.913Z</updated>
  <id>http://charleywu.com/</id>
  
  <author>
    <name>Charley Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM关键知识点图解</title>
    <link href="http://charleywu.com/2017/12/17/JVM%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE%E8%A7%A3/"/>
    <id>http://charleywu.com/2017/12/17/JVM关键知识点图解/</id>
    <published>2017-12-17T08:18:58.000Z</published>
    <updated>2017-12-18T03:47:30.913Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。</p><a id="more"></a><h3 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM-虚拟机内存模型"></p><ol><li><p><strong>类加载器（ClassLoader）</strong>:在JVM启动时或者在类运行时将需要的class加载到JVM中。（下图表示了从 java 源文件到 JVM 的整个过程，可配合理解。</p></li><li><p><strong>执行引擎</strong>：负责执行class文件中包含的字节码指令；</p></li><li><p><strong>内存区（也叫运行时数据区）</strong>：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域。</p><ul><li><strong>方法区(Method Area)</strong>：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然 JVM 规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li><li><strong>java堆(Heap)</strong>：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。</li><li><strong>java栈(Stack)</strong>：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。</li><li><strong>程序计数器(PC Register)</strong>：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</li><li><strong>本地方法栈(Native Method Stack)</strong>：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</li></ul></li><li><p><strong>本地方法接口</strong>：主要是调用C或C++实现的本地方法及返回结果。</p><p>​</p></li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="JVM-类加载的过程"></p><p><strong>以Person person = new Person()为例</strong></p><ol><li>因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;</li><li>执行该类中的static代码块，如果有的话，给Person.class类进行初始化;</li><li>在堆内存中开辟空间分配内存地址;</li><li>在堆内存中建立对象的特有属性，并进行默认初始化;</li><li>对属性进行显示初始化;</li><li>对对象进行构造代码块初始化;</li><li>对对象进行与之对应的构造函数进行初始化;</li><li>将内存地址付给栈内存中的p变量</li></ol><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5.jpg" alt="JVM-内存分配与回收策略"></p><p><strong>GC机制</strong></p><p>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：</p><p><strong>引用计数法：</strong></p><p>给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：</p><p><strong>可达性分析算法：</strong></p><p>以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象、本地方法中引用的对象等。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.jpg" alt="JVM-垃圾回收算法"></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-垃圾回收器.jpg" alt="JVM-垃圾回收器"></p><p>###类加载机制</p><p><strong>类的加载器</strong></p><p>大家都知道，当我们写好一个 Java 程序之后，不是管是 CS 还是 BS应用，都是由若干个 .class 文件组织而成的一个完整的 Java 应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的 class 文件当中，所以经常要从这个 class 文件中要调用另外一个 class 文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有 class 文件，而是根据程序的需要，通过 Java 的类加载机制（ClassLoader）来动态加载某个 class 文件到内存当中的，从而只有 class 文件被载入到了内存之后，才能被其它 class 所引用。所以 ClassLoader 就是用来动态加载 class 文件到内存当中用的。</p><p><strong>双亲机制</strong></p><p>1、原理介绍</p><p>ClassLoader 使用的是双亲委托模型来搜索类的，每个 ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException 异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的 Class实例对象。</p><p>2、为什么要使用双亲委托这种模型呢？</p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的 String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p>3、但是 JVM 在搜索类的时候，又是如何判定两个 class 是相同的呢？</p><p>JVM 在判定两个 class 是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM 才认为这两个 class 是相同的。就算两个 class 是同一份 class 字节码，如果被两个不同的 ClassLoader 实例所加载，JVM 也会认为它们是两个不同 class。比如网络上的一个 Java 类org.classloader.simple.NetClassLoaderSimple，javac 编译之后生成字节码文件 NetClassLoaderSimple.class，ClassLoaderA 和ClassLoaderB 这两个类加载器并读取了 NetClassLoaderSimple.class文件，并分别定义出了 java.lang.Class 实例来表示这个类，对于 JVM 来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个 Class 实例生成具体的对象进行转换时，就会抛运行时异常 java.lang.ClassCaseException，提示这是两个不同的类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPU占用过高问题排查</title>
    <link href="http://charleywu.com/2017/12/15/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://charleywu.com/2017/12/15/CPU占用过高问题排查/</id>
    <published>2017-12-15T03:13:51.000Z</published>
    <updated>2017-12-18T03:58:50.878Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载：</strong></p><p>[]: <a href="https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q" target="_blank" rel="external">https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q</a>    “原文看这里”</p><p>看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。</p><a id="more"></a><h3 id="Step-1：找到CPU占用最高的进程"><a href="#Step-1：找到CPU占用最高的进程" class="headerlink" title="Step-1：找到CPU占用最高的进程"></a>Step-1：找到CPU占用最高的进程</h3><blockquote><p>$ top -c    //显示进程运行信息列表</p><p>$ P        //进程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="https://charleywucl.github.io/images/blog/cpu/step-1.png" alt="step-1"></p><p>上图中消耗CPU最高的进程号为<code>4150</code></p><h3 id="Step-2：找到进程中CPU消耗最高的线程"><a href="#Step-2：找到进程中CPU消耗最高的线程" class="headerlink" title="Step-2：找到进程中CPU消耗最高的线程"></a>Step-2：找到进程中CPU消耗最高的线程</h3><blockquote><p>$ top -Hp 4150    //显示一个进程的线程运行信息列表</p><p>$ P                //线程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="https://charleywucl.github.io/images/blog/cpu/step-2.png" alt="step-2"></p><p>进程<code>4150</code>内，最耗CPU的线程为<code>4157</code></p><h3 id="Step-3：将线程ID转换为十六进制"><a href="#Step-3：将线程ID转换为十六进制" class="headerlink" title="Step-3：将线程ID转换为十六进制"></a>Step-3：将线程ID转换为十六进制</h3><blockquote><p>$ printf “%x\n” 4157    //结果为“103dn”</p></blockquote><p>Java堆栈里，线程id是用16进制表示的</p><h3 id="Step-4：查看堆栈中当前线程在做什么"><a href="#Step-4：查看堆栈中当前线程在做什么" class="headerlink" title="Step-4：查看堆栈中当前线程在做什么"></a>Step-4：查看堆栈中当前线程在做什么</h3><blockquote><p>$ jstack 4150 | grep ‘103dn’ -C5 –color</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[]: &lt;a href=&quot;https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q&lt;/a&gt;    “原文看这里”&lt;/p&gt;
&lt;p&gt;看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Alibaba面试题</title>
    <link href="http://charleywu.com/2017/12/07/Alibaba%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://charleywu.com/2017/12/07/Alibaba面试题/</id>
    <published>2017-12-07T07:46:16.000Z</published>
    <updated>2017-12-07T08:18:20.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>特别声明：</strong>转载，文章出处：<a href="https://github.com/GavinHwa/alibaba" target="_blank" rel="external">https://github.com/GavinHwa/alibaba</a></p><p>无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。</p><p>答案持续更新中…</p><a id="more"></a><ol><li><p>HashMap和Hashtable的区别</p></li><li><p>实现一个保证迭代顺序的HashMap</p></li><li><p>说一说排序算法，稳定性，复杂度</p></li><li><p>说一说GC</p></li><li><p>可以保证的实习时长</p></li><li><p>职业规划</p><p>​</p></li></ol><p>（1）自我介绍。</p><p>（2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？</p><p>（3）HashMap如何实现的？</p><p>（4）HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</p><p>（5）HashMap和HashTable 区别，HashTable线程安全吗？</p><p>（6）进程间通信有哪几种方式？</p><p>（7）JVM分为哪些区，每一个区干吗的？</p><p>（8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？</p><p>（9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？</p><p>（10）快速排序，过程，复杂度？</p><p>（11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。</p><p>（12）TCP如何保证可靠传输？三次握手过程？</p><p>（13）TCP和UDP区别？</p><p>（14）滑动窗口算法？</p><p>（15）Linux下如何进行进程调度的？</p><p>（16）Linux下你常用的命令有哪些？</p><p>（17）操作系统什么情况下会死锁？</p><p>（18）常用的hash算法有哪些？</p><p>（19）什么是一致性哈希？</p><p>（20）如何理解分布式锁？</p><p>（21）数据库中的范式有哪些？</p><p>（22）数据库中的索引的结构？什么情况下适合建索引？</p><p>（23）Java中的NIO，BIO，AIO分别是什么？</p><p>（24）用什么工具调试程序？JConsole，用过吗？</p><p>（25）现在JVM中有一个线程挂起了，如何用工具查出原因？</p><p>（26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？</p><p>（27）同步和异步有什么区别？</p><p>（28）线程池用过吗？</p><p>（29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？</p><p>（30）concurrent包下面，都用过什么？</p><p>（31）常用的数据库有哪些？redis用过吗？</p><p>（32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。</p><p>（33）你知道的开源协议有哪些？</p><p>（34）你知道的开源软件有哪些？</p><p>（35）你最近在看的书有哪些？</p><p>（36）你有什么问题要问我吗？</p><p>（37）了解哪些设计模式？说说都用过哪些设计模式</p><p>（38）如何判断一个单链表是否有环？</p><p>（39）操作系统如何进行分页调度？</p><p>（40）匿名内部类是什么？如何访问在其外面定义的变量？</p><p>1）自我介绍，做过什么项目。</p><p>（2）java虚拟机的区域如何划分，每一个区的动能，这一块自由发挥。</p><p>（3）双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？</p><p>（4）有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？</p><p>（5）HashMap的结构，get()，put()是如何实现的？HashMap有哪些问题？</p><p>（6）ConcurrentHashMap的get()，put()，又是如何实现的？ConcurrentHashMap有哪些问题？ ConcurrentHashMap的锁是读锁还是写锁？</p><p>（7） HashMap与HashTable的区别</p><p>（8）sleep()和wait()分别是哪个类的方法，有什么区别？synchronized底层如何实现的？用在代码块和方法上有什么区别？</p><p>（9）什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？</p><p>（10）什么是死锁？JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？这一块问的很多….问的我懵了. 因为并没有实际操作过 = =</p><p>（11）查看jvm虚拟机里面堆、线程的信息，你用过什么命令？我只用过图形界面VisualVM。。。</p><p>（12）垃圾回收算法有哪些？CMS知道吗？如何工作的？</p><p>（13）数据库中什么是事务？事务的隔离级别？事务的四个特性？什么是脏读，幻读，不可重复读？</p><p>（14）数据库索引的结构有哪些？我说B树和B+树，他说只有这两个吗。我又说全文倒排索引。然后介绍B+树的结构。</p><p>（15）数据库中的分页查询语句怎么写？</p><p>（16）什么是一致性哈希？用来解决什么问题？</p><p>（17）Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</p><p>（18）项目中用到redis，为什么选用redis，了解其他NoSQL数据库吗？在你的项目中是如何运用redis的？key是什么，value是什么？</p><p>（19）归并排序的过程？时间复杂度？空间复杂度？</p><p>（20）你平常用什么排序？快速排序。说说在那些场景下适用，哪些场景下不适用。</p><p>（21）你在项目中做什么？因为我用到Solr，他就问我Solr是如何工作的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;特别声明：&lt;/strong&gt;转载，文章出处：&lt;a href=&quot;https://github.com/GavinHwa/alibaba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/GavinHwa/alibaba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。&lt;/p&gt;
&lt;p&gt;答案持续更新中…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://charleywu.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>LinkedBlockingQueue-Clear原理</title>
    <link href="http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear%E5%8E%9F%E7%90%86/"/>
    <id>http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear原理/</id>
    <published>2017-11-21T10:18:50.000Z</published>
    <updated>2017-11-24T02:15:13.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。</p><a id="more"></a><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      queue.put(<span class="number">10</span>);</div><div class="line">      queue.put(<span class="number">20</span>);</div><div class="line">      queue.put(<span class="number">30</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClear</span><span class="params">()</span></span>&#123;</div><div class="line">    queue.clear();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建一个阻塞队列，然后进行清空；</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>LinkedBlockingQueue Clear()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Atomically removes all of the elements from this queue.</div><div class="line"> * The queue will be empty after this call returns.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">  fullyLock();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p, h = head; (p = h.next) != <span class="keyword">null</span>; h = p) &#123;</div><div class="line">      h.next = h;</div><div class="line">      p.item = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    head = last;</div><div class="line">    <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span></div><div class="line">    <span class="keyword">if</span> (count.getAndSet(<span class="number">0</span>) == capacity)</div><div class="line">      notFull.signal();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    fullyUnlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h3><h4 id="Step-1-新建队列："><a href="#Step-1-新建队列：" class="headerlink" title="Step-1 新建队列："></a>Step-1 新建队列：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp1.png" alt="Step1"></p><h4 id="Step-2-执行初始化语句Node-lt-E-gt-p-h-head"><a href="#Step-2-执行初始化语句Node-lt-E-gt-p-h-head" class="headerlink" title="Step-2 执行初始化语句Node&lt;E&gt; p, h = head;:"></a>Step-2 执行初始化语句<code>Node&lt;E&gt; p, h = head;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp2.png" alt="Step-2"></p><h4 id="Step-3-执行条件判断语句-p-h-next-null"><a href="#Step-3-执行条件判断语句-p-h-next-null" class="headerlink" title="Step-3 执行条件判断语句(p = h.next) != null;:"></a>Step-3 执行条件判断语句<code>(p = h.next) != null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp3.png" alt="Step-3"></p><h4 id="Step-4-执行循环体中h-next-h"><a href="#Step-4-执行循环体中h-next-h" class="headerlink" title="Step-4 执行循环体中h.next = h;:"></a>Step-4 执行循环体中<code>h.next = h;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp4.png" alt="Step-4"></p><h4 id="Step-5-执行循环体中p-item-null"><a href="#Step-5-执行循环体中p-item-null" class="headerlink" title="Step-5 执行循环体中p.item = null;:"></a>Step-5 执行循环体中<code>p.item = null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp5.png" alt="Step-5"></p><h4 id="Step-6-执行控制条件语句h-p"><a href="#Step-6-执行控制条件语句h-p" class="headerlink" title="Step-6 执行控制条件语句h = p:"></a>Step-6 执行控制条件语句<code>h = p</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp6.png" alt="Step-6"></p><h4 id="Step-7-执行循环体直至最后一个节点："><a href="#Step-7-执行循环体直至最后一个节点：" class="headerlink" title="Step-7 执行循环体直至最后一个节点："></a>Step-7 执行循环体直至最后一个节点：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp7.png" alt="Step-7"></p><h4 id="Step-8-执行语句head-last"><a href="#Step-8-执行语句head-last" class="headerlink" title="Step-8 执行语句head = last;:"></a>Step-8 执行语句<code>head = last;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp8.png" alt="Setp8"></p><p>将head、last都指向空节点，触发notFull条件，以便插入线程添加元素，至此队列的清空操作完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://charleywu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://charleywu.com/2017/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://charleywu.com/2017/08/03/数据库事务/</id>
    <published>2017-08-03T02:03:46.000Z</published>
    <updated>2017-11-23T10:05:47.666Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。</p><a id="more"></a><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 (ACID)"></a>事务的特性 (ACID)</h3><ul><li><p><strong>A (Atomacity)  原子性</strong></p><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>C (Consistency) 一致性</strong></p><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>I (Isolation) 隔离性</strong></p><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>D (Durability) 持久性</strong></p><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p><ul><li><p><strong>未提交读 (Read Uncommitted)</strong></p><p>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。Read Uncommitted允许脏读。</p></li><li><p><strong>已提交读 (Read Committed)</strong></p><p>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。Read Commited 不允许脏读，但会出现非重复读。</p></li><li><p><strong>可重复读 (Repeatable Read)</strong></p><p>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</p></li></ul><ul><li><p><strong>串行读 (Serializable)</strong></p><p>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。Serializable 不允许不一致现象的出现。</p><p>​</p></li></ul><p><em>几种隔离级别可能出现的异常场景:</em></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li><strong>脏读 (Dirty Read)：</strong>A 事务读到 B 事务未提交的修改。</li><li><strong>不可重复读 (NonRepeatable Read)：</strong>A 事务还没有结束时，B 事务也访问同一数据。在 A 事务的两次读取之间，由于 B 事务的修改，A 事务两次读到的数据可能是不一样的。</li><li><strong>幻读 (Phantom Read)：</strong>A 事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B 事务也修改这个表中的数据，这种修改是向表中插入一行新数据。操作 A 事务的用户发现表中出现了 B 事务插入的行，就好象发生了幻觉一样。</li></ul><p>MySQL 默认的级别是 REPEATABLE READ（可重复读），这表示在 MySQL 的默认情况下，“脏读”、“不可重复读”是不会发生的。这就需要在更新的时候进行必要的锁定（InnoDB 是采用行级锁的方式），从而保证一致性。需要注意的是 InnoDB 的行锁是通过给索引上的索引项加锁来实现的，这个特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p><p>我们数据库表是 InnoDB 引擎的表，而 MySQL 的 InnoDB 引擎是一个支持事务的引擎，其默认操作模式是 autocommit 自动提交模式。什么意思呢？除非我们显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://charleywu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://charleywu.com/2017/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://charleywu.com/2017/08/02/数据结构与算法/</id>
    <published>2017-08-02T01:28:38.000Z</published>
    <updated>2017-08-02T01:28:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程浅析</title>
    <link href="http://charleywu.com/2017/07/27/Java%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://charleywu.com/2017/07/27/Java线程浅析/</id>
    <published>2017-07-27T02:42:00.000Z</published>
    <updated>2017-11-23T10:07:04.491Z</updated>
    
    <content type="html"><![CDATA[<p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><h3 id="虚拟机线程状态-vs-操作系统线程状态"><a href="#虚拟机线程状态-vs-操作系统线程状态" class="headerlink" title="虚拟机线程状态 vs 操作系统线程状态"></a>虚拟机线程状态 vs 操作系统线程状态</h3><p>Java线程状态指的是虚拟机层面暴露给开发者使用的状态，由Thread.State类定义。底层由于操作系统的千差万别，各操作系统对于线程也有不同的状态，有可能操作系统线程多个状态对应一个Java线程状态；虚拟机的存在就是统一了底层的这些差别，让开发者不必关心这些问题。</p><h3 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h3><p>自JDK1.5开始，Java在Thread；且在给定时间点上，一个线程只能处于这6种状态中的一种。</p><ul><li><p><strong>NEW</strong></p><blockquote><p>Thread state for a thread which has not yet started.</p></blockquote></li></ul><ul><li><p><strong>RUNNABLE</strong></p><blockquote><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p></blockquote></li><li><p><strong>BOLCKED</strong></p><blockquote><p>Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling<code>Object.wait</code>.</p><p>​</p></blockquote></li><li><p><strong>WAITING</strong></p><blockquote><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ul><li><code>Object.wait</code> with no timeout</li><li><code>Thread.join</code> with no timeout</li><li><code>LockSupport.park</code></li></ul><p>A thread in the waiting state is waiting for another thread to perform a particular action. For example, a thread that has called <code>Object.wait()</code> on an object is waiting for another thread to call <code>Object.notify()</code> or <code>Object.notifyAll()</code> on that object. A thread that has called <code>Thread.join()</code> is waiting for a specified thread to terminate.</p><p>​</p></blockquote></li></ul><ul><li><p><strong>TIMED_WAITING</strong></p><blockquote><p>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:</p><ul><li><code>Thread.sleep</code></li></ul><ul><li><code>Object.wait</code> with timeout</li></ul><ul><li><code>Thread.join</code> with timeout</li></ul><ul><li><code>LockSupport.parkNanos</code></li></ul><ul><li><code>LockSupport.parkUntil</code></li></ul></blockquote></li></ul><ul><li><p><strong>TERMINATED</strong></p><blockquote><p>Thread state for a terminated thread. The thread has completed execution.</p></blockquote></li></ul><p><em>Oracle官方文档片段</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static enum Thread.State</div><div class="line">extends Enum&lt;Thread.State&gt;</div><div class="line">  </div><div class="line">A thread state. A thread can be in one of the following states:</div><div class="line">    NEW</div><div class="line">    A thread that has not yet started is in this state.</div><div class="line">    RUNNABLE</div><div class="line">    A thread executing in the Java virtual machine is in this state.</div><div class="line">    BLOCKED</div><div class="line">    A thread that is blocked waiting for a monitor lock is in this state.</div><div class="line">    WAITING</div><div class="line">    A thread that is waiting indefinitely for another thread to perform a particular action is in this state.</div><div class="line">    TIMED_WAITING</div><div class="line">    A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.</div><div class="line">    TERMINATED</div><div class="line">    A thread that has exited is in this state.</div><div class="line">      </div><div class="line">A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</div><div class="line"></div><div class="line">Since:</div><div class="line">1.5</div></pre></td></tr></table></figure><h3 id="Java线程状态迁移"><a href="#Java线程状态迁移" class="headerlink" title="Java线程状态迁移"></a>Java线程状态迁移</h3><p><img src="http://charleywucl.github.io/images/blog/thread/ThreadStateTransform.png" alt="ThreadStateTranform"></p><h3 id="Java线程常用方法"><a href="#Java线程常用方法" class="headerlink" title="Java线程常用方法"></a>Java线程常用方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://charleywu.com/tags/JAVA/"/>
    
  </entry>
  
</feed>
