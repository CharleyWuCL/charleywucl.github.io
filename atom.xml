<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TickTock Ideas</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charleywu.com/"/>
  <updated>2018-10-12T08:19:09.620Z</updated>
  <id>http://charleywu.com/</id>
  
  <author>
    <name>Charley Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot 2.0 WebFlux使用与性能测试</title>
    <link href="http://charleywu.com/2018/10/12/SpringBoot-2-0-WebFlux%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://charleywu.com/2018/10/12/SpringBoot-2-0-WebFlux使用与性能测试/</id>
    <published>2018-10-12T08:19:09.000Z</published>
    <updated>2018-10-12T08:19:09.620Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java常用集合整理</title>
    <link href="http://charleywu.com/2018/08/13/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%95%B4%E7%90%86/"/>
    <id>http://charleywu.com/2018/08/13/Java常用集合整理/</id>
    <published>2018-08-13T07:34:04.000Z</published>
    <updated>2018-08-13T12:20:07.230Z</updated>
    
    <content type="html"><![CDATA[<p>为方便复习，故整理常用集合类List、Set、Map等。</p><a id="more"></a><h3>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Colletion</div><div class="line">  |- List</div><div class="line">  |    |- ArrayList</div><div class="line">  |    |- Vector</div><div class="line">  |    |- LinkedList</div><div class="line">  |</div><div class="line">  |- Set</div><div class="line">  |    |- HashSet</div><div class="line">  |    |- TreeSet</div><div class="line">  |    |- LinkedHashSet</div><div class="line">  |</div><div class="line">  |- Queue</div><div class="line"></div><div class="line">Map</div><div class="line">  |- HashMap</div><div class="line">  |- HashTable</div><div class="line">  |- TreeMap</div></pre></td></tr></table></figure><h3>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><blockquote><p>排列有序，可重复</p><p>底层使用数组</p><p>查询快，增删慢</p><p>扩容公式：当前容量*1.5+1</p></blockquote><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><blockquote><p>排列有序，可重复</p><p>底层使用数组</p><p>查询快，增删慢</p><p>线程安全，效率低</p><p>扩容公式：当前容量*2</p></blockquote><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>###Map</p><p>####HashMap</p><p>####HashTable</p><p>####TreeMap</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为方便复习，故整理常用集合类List、Set、Map等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Apollo主题使用Gitment评论系统</title>
    <link href="http://charleywu.com/2018/08/08/Hexo-Apollo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://charleywu.com/2018/08/08/Hexo-Apollo主题使用Gitment评论系统/</id>
    <published>2018-08-08T04:04:38.000Z</published>
    <updated>2018-08-08T07:54:12.238Z</updated>
    
    <content type="html"><![CDATA[<p>此博客系统使用的是基于Giuhub的Hexo生成的静态页面，一直想用Github的Issues作为评论系统，无意中发现Gitment就是基于这个理念开发的，因此做一个集成，实施步骤如下。</p><a id="more"></a><h3 id="Github授权接入"><a href="#Github授权接入" class="headerlink" title="Github授权接入"></a>Github授权接入</h3><p><a href="https://github.com/settings/applications/new" target="_blank" rel="external">点击此处</a>注册一个新的OAuth application，[Authorization callback URL]这一项特别重要，需要填写GitHub博客地址，如果GitHub绑定了域名需要填写域名，并且需要加<code>http://</code>或<code>https://</code>。</p><p><img src="https://raw.githubusercontent.com/CharleyWuCL/charleywucl.github.io/master/images/blog/gitment/OAuth.png" alt="OAuth"></p><p>注册完成之后会得到一个Client ID和一个Client Secret，这两个后续会用到。已经注册好的OAuth App可以在GitHub –&gt; Settings –&gt; Developer settings –&gt; OAuth Apps里进行查看。</p><h3 id="Apollo主题设置"><a href="#Apollo主题设置" class="headerlink" title="Apollo主题设置"></a>Apollo主题设置</h3><p>因为我的Bolg使用的是Apollo主题，这里需要进行一些配置。</p><p><strong>/themes/apollo/_config.yml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Comment</div><div class="line"># e.g disqus: seansun</div><div class="line">disqus:</div><div class="line">duoshuo:</div><div class="line">gitment:</div><div class="line">    enable: true</div><div class="line">    owner: CharleyWuCL</div><div class="line">    repo: charleywucl.github.io</div><div class="line">    client_id: &lt;Replace me! Your Client ID&gt;</div><div class="line">    client_secret: &lt;Replace me! Your Client Secret&gt;</div></pre></td></tr></table></figure><p><strong>/themes/apollo/layout/partial/comment.jade </strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if theme.gitment.enable</div><div class="line">    - var date = page.date</div><div class="line">    #container</div><div class="line">    link(rel='stylesheet', href='https://imsun.github.io/gitment/style/default.css')</div><div class="line">    script(src='https://imsun.github.io/gitment/dist/gitment.browser.js')</div><div class="line">    script.</div><div class="line">        var gitment = new Gitment(&#123;</div><div class="line">            id: '#&#123;date&#125;',</div><div class="line">            owner: '#&#123;theme.gitment.owner&#125;',</div><div class="line">            repo: '#&#123;theme.gitment.repo&#125;',</div><div class="line">            oauth: &#123;</div><div class="line">                client_id: '#&#123;theme.gitment.client_id&#125;',</div><div class="line">                client_secret: '#&#123;theme.gitment.client_secret&#125;',</div><div class="line">            &#125;,</div><div class="line">        &#125;)</div><div class="line">        gitment.render('container')</div></pre></td></tr></table></figure><h3 id="开放文章评论"><a href="#开放文章评论" class="headerlink" title="开放文章评论"></a>开放文章评论</h3><p>Hexo配置好之后使用<code>hexo clean</code> –&gt; <code>hexo g</code> –&gt; <code>hexo d</code>重新部署一下Bolg。此时点开一篇文章就能看到以下页面。新建的文章需要点击[Initialize Comments]才能开始评论。</p><p><img src="https://raw.githubusercontent.com/CharleyWuCL/charleywucl.github.io/master/images/blog/gitment/Comment.png" alt="comment"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>Page: <a href="https://imsun.net/" target="_blank" rel="external">https://imsun.net/</a></p><p>GitHub:<a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此博客系统使用的是基于Giuhub的Hexo生成的静态页面，一直想用Github的Issues作为评论系统，无意中发现Gitment就是基于这个理念开发的，因此做一个集成，实施步骤如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://charleywu.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Spring cloud zookeeper配置中心搭建</title>
    <link href="http://charleywu.com/2018/08/07/Spring-cloud-zookeeper%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://charleywu.com/2018/08/07/Spring-cloud-zookeeper配置中心搭建/</id>
    <published>2018-08-07T04:33:27.000Z</published>
    <updated>2018-08-09T01:47:18.732Z</updated>
    
    <content type="html"><![CDATA[<p>Spring cloud zookeeper提供了分布式配置中心以及注册中心的功能，可以使用其配置中心功能替代Spring cloud config。</p><p>由于是Spring出品，所以与Spring Boot应用集成非常简单，下面就让我们来了解一下其简单的使用方式。<br><a id="more"></a></p><blockquote><p>Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with Zookeeper. The patterns provided include Service Discovery and Distributed Configuration. </p></blockquote><h3 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h3><p><img src="https://raw.githubusercontent.com/CharleyWuCL/charleywucl.github.io/master/images/blog/zookeeper/arch.png" alt="系统架构"></p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>Maven<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(&apos;org.springframework.cloud:spring-cloud-starter-zookeeper-config:2.0.0.RELEASE&apos;)</div></pre></td></tr></table></figure></p><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>bootstarp.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    zookeeper:</div><div class="line">      enabled: true #Is Zookeeper enabled</div><div class="line">      connect-string: localhost:2181 #Connection string to the Zookeeper cluster</div><div class="line">      max-retries: 3 #Max number of times to retry</div><div class="line">      config:</div><div class="line">        root: config/root #Root folder where the configuration for Zookeeper is kept</div><div class="line">        defaultContext: application #The name of the default context</div></pre></td></tr></table></figure></p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>启动时加载配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line">    <span class="comment">//Server level switch</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String serverEnabled;</div><div class="line"> </div><div class="line">    <span class="comment">//Feature level switch</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;feature.log&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String featureLogEnabled;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配置更新时使用<code>@RefreshScope</code>自动刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RefreshScope</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line">    <span class="comment">//Server level switch</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String serverEnabled;</div><div class="line"> </div><div class="line">    <span class="comment">//Feature level switch</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;feature.log&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String featureLogEnabled;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量的节点需要事先在Zookeeper上配置好。</p><p>###Zookeeper树</p><p><img src="https://raw.githubusercontent.com/CharleyWuCL/charleywucl.github.io/master/images/blog/zookeeper/Zookeeper-tree.png" alt="zk结构"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于应用启动需要从ZK Server上去拉取配置，所以数据节点要预先在ZK上设置好，或者通过application.yml文件给定一个默认值，否则启动会报错。</p><h3 id="关于Zookeeper版本"><a href="#关于Zookeeper版本" class="headerlink" title="关于Zookeeper版本"></a>关于Zookeeper版本</h3><p><strong>3.5.x</strong></p><p>Spring-cloud-zookeeper目前最新版本依赖的zookeeper-client依赖树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">spring-cloud-starter-zookeeper-config:2.0.0.RELEASE</div><div class="line">|</div><div class="line">|--curator-recipes:4.0.1</div><div class="line">|</div><div class="line">|--curator-framework:4.0.1</div><div class="line">||</div><div class="line">||--zookeeper:3.5.3-beta</div><div class="line">|</div><div class="line">|--curator-test:4.0.1</div><div class="line">||</div><div class="line">||--zookeeper:3.5.3-beta</div></pre></td></tr></table></figure><p>如果Zookeeper Server版本为3.5.x，则直接使用就可以。</p><p><strong>3.4.x</strong></p><p>如果Zookeeper Server版本为3.4.X，则需要手动进行Client断兼容。方法如下：</p><p>Maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Curator Recipes --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Curator Test --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Zookeeper --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>Gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compile(&apos;org.apache.curator:curator-recipes:4.0.1) &#123;</div><div class="line">  exclude group: &apos;org.apache.zookeeper&apos;, module: &apos;zookeeper&apos;</div><div class="line">&#125;</div><div class="line">testCompile(&apos;org.apache.curator:curator-test:2.12.0&apos;) &#123;</div><div class="line">  exclude group: &apos;org.apache.zookeeper&apos;, module: &apos;zookeeper&apos;</div><div class="line">&#125;</div><div class="line">compile(&apos;org.apache.zookeeper:zookeeper:3.4.x&apos;)</div></pre></td></tr></table></figure><p><strong>特别注意</strong></p><p>如果要使用3.4.x版本的Zookeeper Client， 那么在使用<code>TestingServer</code>时只能依赖<code>org.apache.curator:curator-test:2.12.0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring cloud zookeeper提供了分布式配置中心以及注册中心的功能，可以使用其配置中心功能替代Spring cloud config。&lt;/p&gt;
&lt;p&gt;由于是Spring出品，所以与Spring Boot应用集成非常简单，下面就让我们来了解一下其简单的使用方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="spring cloud" scheme="http://charleywu.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Kafka概述</title>
    <link href="http://charleywu.com/2018/04/12/Kafka%E6%A6%82%E8%BF%B0/"/>
    <id>http://charleywu.com/2018/04/12/Kafka概述/</id>
    <published>2018-04-12T01:48:56.000Z</published>
    <updated>2018-04-12T01:50:22.765Z</updated>
    
    <content type="html"><![CDATA[<p>kafka是一个分布式的，可分区的，可备份的日志提交服务，它使用独特的设计实现了一个消息系统的功能。</p><a id="more"></a><blockquote><p>Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.</p></blockquote><p><strong>专业术语</strong></p><ul><li><strong>Topic</strong>：指Kafka处理的消息源的不同分类；</li><li><strong>Partition</strong>：Topic物理上的分组，一个topic可以设置为多个partition，每个partition都是一个有序的队列，partition中的每条消息都会被分配一个有序的id（offset）；</li><li><strong>Message</strong>：消息，是通信的基本单位，每个producer可以向一个topic（主题）发送一些消息；</li><li><strong>Producers</strong>：消息生产者，即向Kafka的一个topic发送消息（producer可以选择向topic哪一个partition发送数据）。</li><li><strong>Consumers</strong>：消息消费者，接收topics并处理其发布的消息，同一个topic的数据可以被多个consumer接收；</li><li><strong>Broker</strong>：缓存代理，Kafka集群中的一台或多台服务器统称为broker。</li></ul><p><strong>使用场景</strong></p><ul><li>作为消息系统：具备两个重要模块，队列与发布-订阅。能够保证消息严格有序，通过partition增加并行度。</li><li>作为存储系统：多备份，大容量存储特性，使Kafka能够成为一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。</li><li>作为流处理平台：从输入Topic取数据，经过聚合、join等复杂处理后再写入输出Topic。</li></ul><p><strong>基础架构</strong></p><p>Kafka集群典型架构：</p><p><img src="http://matt33.com/images/2015-11-14-kafka-introduce/kafka.png" alt="kafka"></p><p>消息生产与消费模式：</p><p><img src="http://matt33.com/images/2015-11-14-kafka-introduce/pull.png" alt="pull"></p><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p><strong>Step1 下载压缩包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> tar -xzf kafka_2.11-1.1.0.tgz</div><div class="line"><span class="meta">&gt;</span> cd kafka_2.11-1.1.0</div></pre></td></tr></table></figure><p><strong>Step2 启动服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> bin/zookeeper-server-start.sh config/zookeeper.properties</div><div class="line"><span class="meta">&gt;</span> bin/kafka-server-start.sh config/server.properties</div></pre></td></tr></table></figure><p><strong>Step3 创建Topic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>Create</div><div class="line"><span class="meta">&gt;</span> bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</div><div class="line"><span class="meta">#</span>List</div><div class="line"><span class="meta">&gt;</span> bin/kafka-topics.sh --list --zookeeper localhost:2181</div></pre></td></tr></table></figure><p><strong>Step4 生产消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</div><div class="line">This is a message</div></pre></td></tr></table></figure><p><strong>Step5 消费消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</div></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>Java参数</strong></p><p>JDK8且使用G1垃圾收集器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-Xmx6g -Xms6g -XX:MetaspaceSize=96m -XX:+UseG1GC</div><div class="line">-XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M</div><div class="line">-XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80</div></pre></td></tr></table></figure><p><strong>操作系统</strong></p><ul><li>低CPU，高内存</li><li>文件描述符限制100k+</li><li>文件系统： EXT 或 XFS</li></ul><p><strong>Broker重要配置</strong></p><ul><li><code>log.retention.{ms, minutes, hours}</code>：日志保存时长，默认7天。</li><li><code>log.retention.bytes</code>：日志删除的尺寸阈值，默认无阈值。</li><li><code>message.max.bytes</code>：允许的最大的一个批次的消息大小。</li><li><code>delete.topic.enable</code>：默认为 false，是否允许通过 admin tool 来删除 topic；</li><li><code>min.insync.replicas</code> = 2：当 Producer 的 acks 设置为 all 或 -1 时，<code>min.insync.replicas</code> 代表了必须进行确认的最小 replica 数，如果不够的话 Producer 将会报 <code>NotEnoughReplicas</code> 或 <code>NotEnoughReplicasAfterAppend</code> 异常；</li><li><code>zookeeper.session.timeout.ms</code> ：zookeeper会话超时时间，默认6s，建议设置为30s；</li><li><code>num.io.threads</code>：默认为8，KafkaRequestHandlerPool 的大小。</li></ul><p><strong>Producer重要配置</strong></p><ul><li><code>batch.size</code>：该值设置越大，吞吐越大，但延迟也会越大；</li><li><code>linger.ms</code>：表示 batch 的超时时间，该值越大，吞吐越大、但延迟也会越大；</li><li><code>max.in.flight.requests.per.connection</code>：默认为5，表示 client 在 blocking 之前向单个连接（broker）发送的未确认请求的最大数，超过1时，将会影响数据的顺序性；</li><li><code>compression.type</code>：压缩设置，会提高吞吐量；</li><li><code>acks</code>：此配置是 Producer 在确认一个请求发送完成之前需要收到的反馈信息的数量。 这个参数是为了保证发送请求的可靠性。以下配置方式是允许的：<ul><li><code>acks=0</code> 如果设置为0，则 producer 不会等待服务器的反馈。该消息会被立刻添加到 socket buffer 中并认为已经发送完成。在这种情况下，服务器是否收到请求是没法保证的，并且参数<code>retries</code>也不会生效（因为客户端无法获得失败信息）。每个记录返回的 offset 总是被设置为-1。</li><li><code>acks=1</code> 如果设置为1，leader节点会将记录写入本地日志，并且在所有 follower 节点反馈之前就先确认成功。在这种情况下，如果 leader 节点在接收记录之后，并且在 follower 节点复制数据完成之前产生错误，则这条记录会丢失。</li><li><code>acks=all</code> 如果设置为all，这就意味着 leader 节点会等待所有同步中的副本确认之后再确认这条记录是否发送完成。只要至少有一个同步副本存在，记录就不会丢失。这种方式是对请求传递的最有效保证。acks=-1与acks=all是等效的。</li></ul></li></ul><p><strong>Consumer重要配置</strong></p><ul><li><code>fetch.min.bytes</code> ：消费批次大小。</li><li><code>fetch.max.wait.ms</code>：消费批次最大等待时间。</li><li><code>max.poll.interval.ms</code>：调用 <code>poll()</code> 之后延迟的最大时间，超过这个时间没有调用 <code>poll()</code> 的话，就会认为这个 consumer 挂掉了，将会进行 rebalance；</li><li><code>max.poll.records</code>：当调用 <code>poll()</code> 之后返回最大的 record 数，默认为500；</li><li><code>session.timeout.ms</code>：会话超时时间；</li></ul><h3 id="关于Partition"><a href="#关于Partition" class="headerlink" title="关于Partition"></a>关于Partition</h3><p>Consumer group中消费者实例与partition关系是：</p><ul><li>如果group中的consumer数小于topic中的partition数，那么group中的consumer就会消费多个partition；</li><li>如果group中的consumer数等于topic中的partition数，那么group中的一个consumer就会消费topic中的一个partition；</li><li>如果group中的consumer数大于topic中的partition数，那么group中就会有一部分的consumer处于空闲状态。</li></ul><p><img src="http://matt33.com/images/2015-11-14-kafka-introduce/consumerGroup.png" alt="consumerGroup"></p><h3 id="关于Replication"><a href="#关于Replication" class="headerlink" title="关于Replication"></a>关于Replication</h3><p>Kafka的副本多少决定于几个参数</p><ul><li>broker中<code>default.replication.factor</code></li><li>topic中<code>--replicated-factor</code>，此值会覆盖broker配置里的默认值</li></ul><p>示例：</p><p><img src="http://colobu.com/2017/11/02/kafka-replication/kafka_replication_diagram.png" alt="img"></p><p>上图中有四个broker,一个topic,2个分区，复制因子是3。当producer发送一个消息的时候，它会选择一个分区，比如<code>topic1-part1</code>分区，将消息发送给这个分区的leader， broker2、broker3会拉取这个消息，一旦消息被拉取过来，slave会发送ack给master，这时候master才commit这个log。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka是一个分布式的，可分区的，可备份的日志提交服务，它使用独特的设计实现了一个消息系统的功能。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息中间件选型分析</title>
    <link href="http://charleywu.com/2018/04/11/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E5%88%86%E6%9E%90/"/>
    <id>http://charleywu.com/2018/04/11/消息中间件选型分析/</id>
    <published>2018-04-11T12:05:00.000Z</published>
    <updated>2018-04-11T12:08:50.102Z</updated>
    
    <content type="html"><![CDATA[<p>开源消息中间件种类繁多，如何选型成为问题。引用网上文章进行阐述。<br><a id="more"></a></p><p>转载自：<a href="https://mp.weixin.qq.com/s/ad7jibTb5nTzh3nDQYKFeg" target="_blank" rel="external">朱小厮-消息中间件选型分析</a></p><h3 id="各消息队列简述"><a href="#各消息队列简述" class="headerlink" title="各消息队列简述"></a>各消息队列简述</h3><ul><li><strong>ActiveMQ</strong>是Apache出品的、采用Java语言编写的完全基于JMS1.1规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为Apollo，号称下一代ActiveMQ，有兴趣的同学可行了解。</li><li><strong>RabbitMQ</strong>是采用Erlang语言实现的AMQP协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</li><li><strong>Kafka</strong>起初是由LinkedIn公司采用Scala语言开发的一个分布式、多分区、多副本且基于zookeeper协调的分布式消息系统，现已捐献给Apache基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark、Flink等都支持与Kafka集成。</li><li><strong>RocketMQ</strong>是阿里开源的消息中间件，目前已经捐献个Apache基金会，它是由Java语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双11的洗礼，实力不容小觑。</li><li><strong>ZeroMQ</strong>号称史上最快的消息队列，基于C语言开发。ZeroMQ是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的Socket API上加上一层封装而已。</li></ul><p>目前市面上的消息中间件还有很多，比如腾讯系的PhxQueue、CMQ、CKafka，又比如基于Go语言的NSQ，有时人们也把类似Redis的产品也看做消息中间件的一种，当然它们都很优秀，但是本文篇幅限制无法穷极所有，下面会针对性的挑选RabbitMQ和Kafka两款典型的消息中间件来做分析，力求站在一个公平公正的立场来阐述消息中间件选型中的各个要点。</p><h3 id="选型要素"><a href="#选型要素" class="headerlink" title="选型要素"></a>选型要素</h3><p>大致从功能、性能、可靠性、可用性、运维管理、社区生态等方面综合考虑进行选型。</p><h4 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h4><ul><li><strong>优先级队列</strong></li></ul><p>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><ul><li><strong>延迟队列</strong></li></ul><p>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”？这个是延迟队列的一种典型应用场景。延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。实际应用中大多采用基于队列的延迟，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略（比如定时）即可投递超时的消息。</p><ul><li><strong>死信队列</strong></li></ul><p>由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）,进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</p><ul><li><strong>重试队列</strong></li></ul><p>重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到Broker中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。举个例子：消息第一次消费失败入重试队列Q1，Q1的重新投递延迟为5s，在5s过后重新投递该消息；如果消息再次消费失败则入重试队列Q2，Q2的重新投递延迟为10s，在10s过后再次投递该消息。以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发；延迟队列作用一次，而重试队列的作用范围会向后传递。</p><ul><li><strong>消费模式</strong></li></ul><p>消费模式分为推（push）模式和拉（pull）模式。推模式是指由Broker主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。而拉模式是指消费端主动向Broker端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</p><ul><li><strong>广播消费</strong></li></ul><p>消息一般有两种传递模式：点对点（P2P，Point-to-Point）模式和发布/订阅（Pub/Sub）模式。对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。RabbitMQ是一种典型的点对点模式，而Kafka是一种典型的发布订阅模式。但是RabbitMQ中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka中也能以点对点的形式消费，你完全可以把其消费组（consumer group）的概念看成是队列的概念。不过对比来说，Kafka中因为有了消息回溯功能的存在，对于广播消费的力度支持比RabbitMQ的要强。</p><ul><li><strong>消息回溯</strong></li></ul><p>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</p><ul><li><strong>消息堆积+持久化</strong></li></ul><p>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。消息堆积分内存式堆积和磁盘式堆积。RabbitMQ是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中。Kafka是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引纽约时报的案例（<a href="https://www.confluent.io/blog/publishing-apache-kafka-new-york-times/），其直接将Kafka用作存储系统。" target="_blank" rel="external">https://www.confluent.io/blog/publishing-apache-kafka-new-york-times/），其直接将Kafka用作存储系统。</a></p><ul><li><strong>消息追踪</strong></li></ul><p>对于分布式架构系统中的链路追踪（trace）而言，大家一定不会陌生。对于消息中间件而言，消息的链路追踪（以下简称消息追踪）同样重要。对于消息追踪最通俗的理解就是要知道消息从哪来，存在哪里以及发往哪里去。基于此功能下，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</p><ul><li><strong>消息过滤</strong></li></ul><p>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。就以kafka而言，完全可以将不同类别的消息发送至不同的topic中，由此可以实现某种意义的消息过滤，或者Kafka还可以根据分区对同一个topic中的消息进行分类。不过更加严格意义上的消息过滤应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。同样以Kafka为例，可以通过客户端提供的ConsumerInterceptor接口或者Kafka Stream的filter功能进行消息过滤。</p><ul><li><strong>多租户</strong></li></ul><p>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。RabbitMQ就能够支持多租户技术，每一个租户表示为一个vhost，其本质上是一个独立的小型RabbitMQ服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。vhost就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个RabbitMQ中的众多客户区分开，又可以避免队列和交换器等命名冲突。</p><ul><li><strong>多协议支持</strong></li></ul><p>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息（生产者需要知道如何构造消息，消费者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。有效的消息一定具有某种格式，而没有格式的消息是没有意义的。一般消息层面的协议有AMQP、MQTT、STOMP、XMPP等（消息领域中的JMS更多的是一个规范而不是一个协议），支持的协议越多其应用范围就会越广，通用性越强，比如RabbitMQ能够支持MQTT协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如Kafka。</p><ul><li><strong>跨语言支持</strong></li></ul><p>对很多公司而言，其技术栈体系中会有多种编程语言，如C/C++、JAVA、Go、PHP等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。跨语言的支持力度也可以从侧面反映出一个消息中间件的流行程度。</p><ul><li><strong>流量控制</strong></li></ul><p>流量控制（flow control）针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应。通常的流控方法有Stop-and-wait、滑动窗口以及令牌桶等。</p><ul><li><strong>消息顺序性</strong></li></ul><p>顾名思义，消息顺序性是指保证消息有序。这个功能有个很常见的应用场景就是CDC（Change Data Chapture），以MySQL为例，如果其传输的binlog的顺序出错，比如原本是先对一条数据加1，然后再乘以2，发送错序之后就变成了先乘以2后加1了，造成了数据不一致。</p><ul><li><strong>安全机制</strong></li></ul><p>在Kafka 0.9版本之后就开始增加了身份认证和权限控制两种安全机制。身份认证是指客户端与服务端连接进行身份认证，包括客户端与Broker之间、Broker与Broker之间、Broker与ZooKeeper之间的连接认证，目前支持SSL、SASL等认证机制。权限控制是指对客户端的读写操作进行权限控制，包括对消息或Kafka集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。对于RabbitMQ而言，其同样提供身份认证（TLS/SSL、SASL）和权限控制（读写操作）的安全机制。</p><ul><li><strong>消息幂等性</strong></li></ul><p>对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。对于大多数消息中间件而言，一般只提供At most once和At least once两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</p><p>Kafka自0.11版本开始引入了幂等性和事务，Kafka的幂等性是指单个生产者对于单分区单会话的幂等，而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让Kafka具备EOS（Exactly Once Semantic）的能力。</p><p>不过如果要考虑全局的幂等，还需要与从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法有消息中间件层面来保证的。如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</p><ul><li><strong>事务性消息</strong></li></ul><p>事务本身是一个并不陌生的词汇，事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。支持事务的消息中间件并不在少数，Kafka和RabbitMQ都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</p><p>下表是对Kafka与RabbitMQ功能的总结性对比及补充说明。</p><table><thead><tr><th><strong>功能项</strong></th><th><strong>Kafka**</strong>（1.1.0版本）**</th><th><strong>RabbitMQ**</strong>（3.6.10版本）**</th></tr></thead><tbody><tr><td><strong>优先级队列</strong></td><td>不支持</td><td>支持。建议优先级大小设置在0-10之间。</td></tr><tr><td><strong>延迟队列</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>死信队列</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>重试队列</strong></td><td>不支持</td><td>不支持。RabbitMQ中可以参考延迟队列实现一个重试队列，二次封装比较简单。如果要在Kafka中实现重试队列，首先得实现延迟队列的功能，相对比较复杂。</td></tr><tr><td><strong>消费模式</strong></td><td>推模式</td><td>推模式+拉模式</td></tr><tr><td><strong>广播消费</strong></td><td>支持。Kafka对于广播消费的支持相对而言更加正统。</td><td>支持，但力度较Kafka弱。</td></tr><tr><td><strong>消息回溯</strong></td><td>支持。Kafka支持按照offset和timestamp两种维度进行消息回溯。</td><td>不支持。RabbitMQ中消息一旦被确认消费就会被标记删除。</td></tr><tr><td><strong>消息堆积</strong></td><td>支持</td><td>支持。一般情况下，内存堆积达到特定阈值时会影响其性能，但这不是绝对的。如果考虑到吞吐这因素，Kafka的堆积效率比RabbitMQ总体上要高很多。</td></tr><tr><td><strong>持久化</strong></td><td>支持</td><td>支持</td></tr><tr><td><strong>消息追踪</strong></td><td>不支持。消息追踪可以通过外部系统来支持，但是支持粒度没有内置的细腻。</td><td>支持。RabbitMQ中可以采用Firehose或者rabbitmq_tracing插件实现。不过开启rabbitmq_tracing插件件会大幅影响性能，不建议生产环境开启，反倒是可以使用Firehose与外部链路系统结合提供高细腻度的消息追踪支持。</td></tr><tr><td><strong>消息过滤</strong></td><td>客户端级别的支持</td><td>不支持。但是二次封装一下也非常简单。</td></tr><tr><td><strong>多租户</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>多协议支持</strong></td><td>只支持定义协议，目前几个主流版本间存在兼容性问题。</td><td>RabbitMQ本身就是AMQP协议的实现，同时支持MQTT、STOMP等协议。</td></tr><tr><td><strong>跨语言支持</strong></td><td>采用Scala和Java编写，支持多种语言的客户端。</td><td>采用Erlang编写，支持多种语言的客户端。</td></tr><tr><td><strong>流量控制</strong></td><td>支持client和user级别，通过主动设置可将流控作用于生产者或消费者。</td><td>RabbitMQ的流控基于Credit-Based算法，是内部被动触发的保护机制，作用于生产者层面。</td></tr><tr><td><strong>消息顺序性</strong></td><td>支持单分区（partition）级别的顺序性。</td><td>顺序性的条件比较苛刻，需要单线程发送、单线程消费并且不采用延迟队列、优先级队列等一些高级功能，从某种意义上来说不算支持顺序性。</td></tr><tr><td><strong>安全机制</strong></td><td>（TLS/SSL、SASL）身份认证和（读写）权限控制</td><td>与Kafka相似</td></tr><tr><td><strong>幂等性</strong></td><td>支持单个生产者单分区单会话的幂等性。</td><td>不支持</td></tr><tr><td><strong>事务性消息</strong></td><td>支持</td><td>支持</td></tr></tbody></table><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度。有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得，Kafka在开启幂等、事务功能的时候会使其性能降低，RabbitMQ在开启rabbitmq_tracing插件的时候也会极大的影响其性能。消息中间件的性能一般是指其吞吐量，虽然从功能维度上来说，RabbitMQ的优势要大于Kafka，但是Kafka的吞吐量要比RabbitMQ高出1至2个数量级，一般RabbitMQ的单机QPS在万级别之内，而Kafka的单机QPS可以维持在十万级别，甚至可以达到百万级。</p><blockquote><p>消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb/8)/100W，即约等于134B，换句话说如果消息体大小超过134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</p></blockquote><p>时延作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用RPC的方式实现。消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢？消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下可以让整体上下游的应用之间的级联动作更加高效，虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</p><h4 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h4><p>消息丢失是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；而消息中间件的可用性是指无故障运行的时间百分比，通常用几个9来衡量。</p><p>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议。对于Kafka而言，其采用的是类似PacificA的一致性协议，通过ISR（In-Sync-Replica）来保证多副本之间的同步，并且支持强一致性语义（通过acks实现）。对应的RabbitMQ是通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在master节点宕机异常之后可以提升slave作为新的master而继续提供服务来保障可用性。Kafka设计之初是为日志处理而生，给人们留下了数据可靠性要求不要的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考KIP101。就目前而言，在金融支付领域使用RabbitMQ居多，而在日志处理、大数据等方面Kafka使用居多，随着RabbitMQ性能的不断提升和Kafka可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</p><blockquote><p>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka和RabbitMQ都可以支持同步刷盘，但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</p></blockquote><p>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其用可用能力及范围，比如前面提到的RabbitMQ支持多种消息协议，这个就是基于其插件化的扩展实现。还有从集群部署上来讲，归功于Kafka的水平扩展能力，其基本上可以达到线性容量提升的水平，在LinkedIn实践介绍中就提及了有部署超过千台设备的Kafka集群。</p><h4 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h4><p>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复。业务线流量有峰值又低谷，尤其是电商领域，那么怎样前进行有效的容量评估，尤其是大促期间？脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活？这些都离不开消息中间件的衍生产品——运维管理。</p><p>运维管理也可以进行进一步的细分，比如：申请、审核、监控、告警、管理、容灾、部署等。</p><p>申请、审核很好理解，在源头对资源进行管控，既可以进行有效校正应用方的使用规范，配和监控也可以做好流量统计与流量评估工作，一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</p><p>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，即可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。除了一般的监控项（比如硬件、GC等）之外，对于消息中间件还需要关注端到端时延、消息审计、消息堆积等方面。对于RabbitMQ而言，最正统的监控管理工具莫过于rabbitmq_management插件了，但是社区内还有AppDynamics, Collectd, DataDog, Ganglia, Munin, Nagios, New Relic, Prometheus, Zenoss等多种优秀的产品。Kafka在此方面也毫不逊色，比如：Kafka Manager, Kafka Monitor, Kafka Offset Monitor, Burrow, Chaperone, Confluent Control Center等产品，尤其是Cruise还可以提供自动化运维的功能。</p><p>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，对于Kafka而言，可以参考MirrorMarker、uReplicator等产品，而RabbitMQ可以参考Federation和Shovel。</p><h4 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h4><p>对于目前流行的编程语言而言，如Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。对于消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深；相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你以“站在巨人的肩膀上”。在运维管理维度我们提及了Kafka和RabbitMQ都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</p><h3 id="选型误区"><a href="#选型误区" class="headerlink" title="选型误区"></a>选型误区</h3><p>在进行消息中间件选型之前可以先问自己一个问题：是否真的需要一个消息中间件？在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件？很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</p><p>很多人面对消息中间件时会有一种自研的冲动，你完全可以对Java中的ArrayBlockingQueue做一个简单的封装，你也可以基于文件、数据库、Redis等底层存储封装而形成一个消息中间件。消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。自研还有会交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。是否真的有自研的必要？如果不是KPI的压迫可以先考虑下这2个问题：1. 目前市面上的消息中间件是否都真的无法满足目前业务需求？ 2. 团队是否有足够的能力、人力、财力、精力来支持自研？</p><p>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好，还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</p><p>消息中间件犹如小马过河，选择合适的才最重要，这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等6个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂，笔者鄙见：RabbitMQ在于routing，而Kafka在于streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</p><p>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而对于长期发展而言，生态又比性能以及功能都要重要。</p><p>很多时候，对于可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这3个维度去努力保证，《<a href="http://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483834&amp;idx=1&amp;sn=1a6b968e6e2624bfdf036cd5c797a238&amp;chksm=fb0beb2ecc7c6238fb849963abcf75e387815d1a92d4b7c283f2cd1a9f36de67765d5ac112bf&amp;scene=21#wechat_redirect" target="_blank" rel="external">RabbitMQ消息可靠性分析</a>》这篇文章就从这3个维度去分析了RabbitMQ的可靠性。</p><p>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件只有蹩脚的程序员，但是让一个C栈的团队去深挖PhxQueue总比去深挖Scala编写的Kafka要容易的多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开源消息中间件种类繁多，如何选型成为问题。引用网上文章进行阐述。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM关键知识点图解</title>
    <link href="http://charleywu.com/2017/12/17/JVM%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE%E8%A7%A3/"/>
    <id>http://charleywu.com/2017/12/17/JVM关键知识点图解/</id>
    <published>2017-12-17T08:18:58.000Z</published>
    <updated>2017-12-18T03:47:30.913Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。</p><a id="more"></a><h3 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM-虚拟机内存模型"></p><ol><li><p><strong>类加载器（ClassLoader）</strong>:在JVM启动时或者在类运行时将需要的class加载到JVM中。（下图表示了从 java 源文件到 JVM 的整个过程，可配合理解。</p></li><li><p><strong>执行引擎</strong>：负责执行class文件中包含的字节码指令；</p></li><li><p><strong>内存区（也叫运行时数据区）</strong>：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域。</p><ul><li><strong>方法区(Method Area)</strong>：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然 JVM 规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li><li><strong>java堆(Heap)</strong>：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。</li><li><strong>java栈(Stack)</strong>：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。</li><li><strong>程序计数器(PC Register)</strong>：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</li><li><strong>本地方法栈(Native Method Stack)</strong>：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</li></ul></li><li><p><strong>本地方法接口</strong>：主要是调用C或C++实现的本地方法及返回结果。</p><p>​</p></li></ol><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="JVM-类加载的过程"></p><p><strong>以Person person = new Person()为例</strong></p><ol><li>因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;</li><li>执行该类中的static代码块，如果有的话，给Person.class类进行初始化;</li><li>在堆内存中开辟空间分配内存地址;</li><li>在堆内存中建立对象的特有属性，并进行默认初始化;</li><li>对属性进行显示初始化;</li><li>对对象进行构造代码块初始化;</li><li>对对象进行与之对应的构造函数进行初始化;</li><li>将内存地址付给栈内存中的p变量</li></ol><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5.jpg" alt="JVM-内存分配与回收策略"></p><p><strong>GC机制</strong></p><p>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：</p><p><strong>引用计数法：</strong></p><p>给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：</p><p><strong>可达性分析算法：</strong></p><p>以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象、本地方法中引用的对象等。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.jpg" alt="JVM-垃圾回收算法"></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="https://charleywucl.github.io/images/blog/jvm/JVM-垃圾回收器.jpg" alt="JVM-垃圾回收器"></p><p>###类加载机制</p><p><strong>类的加载器</strong></p><p>大家都知道，当我们写好一个 Java 程序之后，不是管是 CS 还是 BS应用，都是由若干个 .class 文件组织而成的一个完整的 Java 应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的 class 文件当中，所以经常要从这个 class 文件中要调用另外一个 class 文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有 class 文件，而是根据程序的需要，通过 Java 的类加载机制（ClassLoader）来动态加载某个 class 文件到内存当中的，从而只有 class 文件被载入到了内存之后，才能被其它 class 所引用。所以 ClassLoader 就是用来动态加载 class 文件到内存当中用的。</p><p><strong>双亲机制</strong></p><p>1、原理介绍</p><p>ClassLoader 使用的是双亲委托模型来搜索类的，每个 ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException 异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的 Class实例对象。</p><p>2、为什么要使用双亲委托这种模型呢？</p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的 String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p>3、但是 JVM 在搜索类的时候，又是如何判定两个 class 是相同的呢？</p><p>JVM 在判定两个 class 是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM 才认为这两个 class 是相同的。就算两个 class 是同一份 class 字节码，如果被两个不同的 ClassLoader 实例所加载，JVM 也会认为它们是两个不同 class。比如网络上的一个 Java 类org.classloader.simple.NetClassLoaderSimple，javac 编译之后生成字节码文件 NetClassLoaderSimple.class，ClassLoaderA 和ClassLoaderB 这两个类加载器并读取了 NetClassLoaderSimple.class文件，并分别定义出了 java.lang.Class 实例来表示这个类，对于 JVM 来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个 Class 实例生成具体的对象进行转换时，就会抛运行时异常 java.lang.ClassCaseException，提示这是两个不同的类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPU占用过高问题排查</title>
    <link href="http://charleywu.com/2017/12/15/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://charleywu.com/2017/12/15/CPU占用过高问题排查/</id>
    <published>2017-12-15T03:13:51.000Z</published>
    <updated>2017-12-18T04:02:19.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载：</strong><a href="https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q" target="_blank" rel="external">原文看这里</a></p><p>看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。</p><a id="more"></a><h3 id="Step-1：找到CPU占用最高的进程"><a href="#Step-1：找到CPU占用最高的进程" class="headerlink" title="Step-1：找到CPU占用最高的进程"></a>Step-1：找到CPU占用最高的进程</h3><blockquote><p>$ top -c    //显示进程运行信息列表</p><p>$ P        //进程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="https://charleywucl.github.io/images/blog/cpu/step-1.png" alt="step-1"></p><p>上图中消耗CPU最高的进程号为<code>4150</code></p><h3 id="Step-2：找到进程中CPU消耗最高的线程"><a href="#Step-2：找到进程中CPU消耗最高的线程" class="headerlink" title="Step-2：找到进程中CPU消耗最高的线程"></a>Step-2：找到进程中CPU消耗最高的线程</h3><blockquote><p>$ top -Hp 4150    //显示一个进程的线程运行信息列表</p><p>$ P                //线程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="https://charleywucl.github.io/images/blog/cpu/step-2.png" alt="step-2"></p><p>进程<code>4150</code>内，最耗CPU的线程为<code>4157</code></p><h3 id="Step-3：将线程ID转换为十六进制"><a href="#Step-3：将线程ID转换为十六进制" class="headerlink" title="Step-3：将线程ID转换为十六进制"></a>Step-3：将线程ID转换为十六进制</h3><blockquote><p>$ printf “%x\n” 4157    //结果为“103dn”</p></blockquote><p>Java堆栈里，线程id是用16进制表示的</p><h3 id="Step-4：查看堆栈中当前线程在做什么"><a href="#Step-4：查看堆栈中当前线程在做什么" class="headerlink" title="Step-4：查看堆栈中当前线程在做什么"></a>Step-4：查看堆栈中当前线程在做什么</h3><blockquote><p>$ jstack 4150 | grep ‘103dn’ -C5 –color</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文看这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Alibaba面试题</title>
    <link href="http://charleywu.com/2017/12/07/Alibaba%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://charleywu.com/2017/12/07/Alibaba面试题/</id>
    <published>2017-12-07T07:46:16.000Z</published>
    <updated>2017-12-18T06:46:50.050Z</updated>
    
    <content type="html"><![CDATA[<p><strong>特别声明：</strong>转载，文章出处：<a href="https://github.com/GavinHwa/alibaba" target="_blank" rel="external">https://github.com/GavinHwa/alibaba</a></p><p>无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。</p><p>答案持续更新中…</p><a id="more"></a><ol><li><p>HashMap和Hashtable的区别</p></li><li><p>实现一个保证迭代顺序的HashMap</p></li><li><p>说一说排序算法，稳定性，复杂度</p></li><li><p>说一说GC</p></li><li><p>可以保证的实习时长</p></li><li><p>职业规划</p><p>​</p></li></ol><p>（1）自我介绍。</p><p>（2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？</p><p>（3）HashMap如何实现的？</p><p>（4）HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</p><p>（5）HashMap和HashTable 区别，HashTable线程安全吗？</p><p>（6）进程间通信有哪几种方式？</p><p>（7）JVM分为哪些区，每一个区干吗的？</p><p>（8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？</p><p>（9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？</p><p>（10）快速排序，过程，复杂度？</p><p>（11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。</p><p>（12）TCP如何保证可靠传输？三次握手过程？</p><p>（13）TCP和UDP区别？</p><p>（14）滑动窗口算法？</p><p>（15）Linux下如何进行进程调度的？</p><p>（16）Linux下你常用的命令有哪些？</p><p>（17）操作系统什么情况下会死锁？</p><p>（18）常用的hash算法有哪些？</p><p>（19）什么是一致性哈希？</p><p>（20）如何理解分布式锁？</p><p>（21）数据库中的范式有哪些？</p><p>（22）数据库中的索引的结构？什么情况下适合建索引？</p><p>（23）Java中的NIO，BIO，AIO分别是什么？</p><p>（24）用什么工具调试程序？JConsole，用过吗？</p><p>（25）现在JVM中有一个线程挂起了，如何用工具查出原因？</p><p>（26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？</p><p>（27）同步和异步有什么区别？</p><p>（28）线程池用过吗？</p><p>（29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？</p><p>（30）concurrent包下面，都用过什么？</p><p>（31）常用的数据库有哪些？redis用过吗？</p><p>（32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。</p><p>（33）你知道的开源协议有哪些？</p><p>（34）你知道的开源软件有哪些？</p><p>（35）你最近在看的书有哪些？</p><p>（36）你有什么问题要问我吗？</p><p>（37）了解哪些设计模式？说说都用过哪些设计模式</p><p>（38）如何判断一个单链表是否有环？</p><p>（39）操作系统如何进行分页调度？</p><p>（40）匿名内部类是什么？如何访问在其外面定义的变量？</p><p>1）自我介绍，做过什么项目。</p><p>（2）java虚拟机的区域如何划分，每一个区的动能，这一块自由发挥。</p><p>（3）双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？</p><p>（4）有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？</p><p>（5）HashMap的结构，get()，put()是如何实现的？HashMap有哪些问题？</p><p>（6）ConcurrentHashMap的get()，put()，又是如何实现的？ConcurrentHashMap有哪些问题？ ConcurrentHashMap的锁是读锁还是写锁？</p><p>（7） HashMap与HashTable的区别</p><p>（8）sleep()和wait()分别是哪个类的方法，有什么区别？synchronized底层如何实现的？用在代码块和方法上有什么区别？</p><p>（9）什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？</p><p>（10）什么是死锁？JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？这一块问的很多….问的我懵了. 因为并没有实际操作过 = =</p><p>（11）查看jvm虚拟机里面堆、线程的信息，你用过什么命令？我只用过图形界面VisualVM。。。</p><p>（12）垃圾回收算法有哪些？CMS知道吗？如何工作的？</p><p>（13）数据库中什么是事务？事务的隔离级别？事务的四个特性？什么是脏读，幻读，不可重复读？</p><p>（14）数据库索引的结构有哪些？我说B树和B+树，他说只有这两个吗。我又说全文倒排索引。然后介绍B+树的结构。</p><p>（15）数据库中的分页查询语句怎么写？</p><p>（16）什么是一致性哈希？用来解决什么问题？</p><p>（17）Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</p><p>（18）项目中用到redis，为什么选用redis，了解其他NoSQL数据库吗？在你的项目中是如何运用redis的？key是什么，value是什么？</p><p>（19）归并排序的过程？时间复杂度？空间复杂度？</p><p>（20）你平常用什么排序？快速排序。说说在那些场景下适用，哪些场景下不适用。</p><p>（21）你在项目中做什么？因为我用到Solr，他就问我Solr是如何工作的？</p><p><strong>四. 集合框架，list，map，set都有哪些具体的实现类，区别都是什么?</strong></p><p>1.List,Set都是继承自 Collection 接口，Map 则不是;</p><p>2.List特点：元素有放入顺序，元素可重复;</p><p>  Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注    意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的        HashCode决定的，其位置其实是固定的，加入Set 的Object必须定    义equals()方法;</p><p>  另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是 set只能用迭代，因为他无序，无法用下标来取得想要的值）。</p><p>3.Set和List对比：</p><p>  Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元  素位置改变。</p><p>  List：和数组类似，List可以动态增长，查找元素效率高，插入删除元 素效率低，因为会引起其他元素位置改变。</p><p>4.Map适合储存键值对的数据。</p><p>5.线程安全集合类与非线程安全集合类</p><p>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;</p><p>HashMap是非线程安全的，HashTable是线程安全的;</p><p>StringBuilder是非线程安全的，StringBuffer是线程安全的。</p><p>下面是这些类具体的使用介绍：</p><p><strong>ArrayList与LinkedList的区别和适用场景</strong></p><p>Arraylist：</p><p>优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p><p>缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p><p>LinkedList：</p><p>优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</p><p>缺点：因为LinkedList要移动指针,所以查询操作性能比较低。</p><p>适用场景分析：</p><p>当需要对数据进行对此访问的情况下选用 ArrayList，当需要对数据进行多次增加删除修改时采用 LinkedList。</p><p><strong>ArrayList 与 Vector 的区别和适用场景</strong></p><p>ArrayList有三个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public ArrayList(int initialCapacity)//构造一个具有指定初始容量的空列表。    </div><div class="line">public ArrayList()//构造一个初始容量为10的空列表。    </div><div class="line">public ArrayList(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 的元素的列表</div></pre></td></tr></table></figure><p>Vector有四个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Vector()//使用指定的初始容量和等于零的容量增量构造一个空向量。    </div><div class="line">public Vector(int initialCapacity)//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。    </div><div class="line">public Vector(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 中的元素的向量    </div><div class="line">public Vector(int initialCapacity,int capacityIncrement)//使用指定的初始容量和容量增量构造一个空的向量</div></pre></td></tr></table></figure><p><strong>ArrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</strong></p><p>1).Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</p><p>2).两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</p><p>3).Vector可以设置增长因子，而ArrayList不可以。</p><p>4).Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p><p><strong>适用场景：</strong></p><p>1.Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p><p>2.如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p><p><strong>HashSet与Treeset的适用场景</strong></p><p>1.TreeSet 是二叉树（红黑树的树据结构）实现的,Treeset中的数据是自动排好序的，不允许放入null值。</p><p>2.HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例。</p><p><strong>适用场景分析:</strong></p><p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p><p><strong>HashMap与TreeMap、HashTable的区别及适用场景</strong></p><p>HashMap 非线程安全 </p><p>HashMap：基于哈希表(散列表)实现。使用 HashMap 要求添加的键类明确定义了 hashCode() 和 equals()[可以重写 hashCode() 和equals()]，为了优化 HashMap 空间的使用，您可以调优初始容量和负载因子。其中散列表的冲突处理主要分两种，一种是开放定址法，另一种是链表法。HashMap 的实现中采用的是链表法。</p><p>TreeMap：非线程安全基于红黑树实现。TreeMap 没有调优选项，因为该树总处于平衡状态。</p><p><strong>适用场景分析：</strong></p><p>HashMap和HashTable:HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。HashTable同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。</p><p>HashMap：适用于Map中插入、删除和定位元素。</p><p>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p><p>(ps:其实我们工作的过程中对集合的使用是很频繁的,稍加注意并总结积累一下,在面试的时候应该会回答的很轻松)</p><p><strong>五. concurrentHashmap原理，原子类。</strong></p><p>ConcurrentHashMap 作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比 HashTable 的全表锁在性能上的提升非常之大.</p><p><strong>六. volatile原理</strong></p><p>在《Java并发编程：核心理论》一文中，我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p><p>参考文章 </p><p><a href="https://link.jianshu.com/?t=https://www.cnblogs.com/paddix/p/5428507.html" target="_blank" rel="external">https://link.jianshu.com/?t=https://www.cnblogs.com/paddix/p/5428507.html</a></p><p><strong>七. 多线程的使用场景</strong></p><p>使用多线程就一定效率高吗？ 有时候使用多线程并不是为了提高效率，而是使得CPU能够同时处理多个事件。</p><p>1).为了不阻塞主线程,启动其他线程来做好事的事情,比如APP中耗时操作都不在UI中做.</p><p>2).实现更快的应用程序,即主线程专门监听用户请求,子线程用来处理用户请求,以获得大的吞吐量.感觉这种情况下，多线程的效率未必高。 这种情况下的多线程是为了不必等待， 可以并行处理多条数据。</p><p>比如JavaWeb的就是主线程专门监听用户的HTTP请求，然后启动子线程去处理用户的HTTP请求。</p><p>3).某种虽然优先级很低的服务，但是却要不定时去做。</p><p>比如Jvm的垃圾回收。</p><p>4.)某种任务，虽然耗时，但是不耗CPU的操作时，开启多个线程，效率会有显著提高。</p><p>比如读取文件，然后处理。 磁盘IO是个很耗费时间，但是不耗CPU计算的工作。 所以可以一个线程读取数据，一个线程处理数据。肯定比一个线程读取数据，然后处理效率高。 因为两个线程的时候充分利用了CPU等待磁盘IO的空闲时间。</p><p><strong>八. JAVA常量池</strong></p><p>Interger 中的128(-128~127)</p><p>a.当数值范围为-128~127时：如果两个 new 出来 Integer 对象，即使值相同，通过“==”比较结果为false，但两个对象直接赋值，则通过“==”比较结果为“true，这一点与String非常相似。</p><p>b.当数值不在-128~127时，无论通过哪种方式，即使两个对象的值相等，通过“==”比较，其结果为false；</p><p>c.当一个Integer对象直接与一个int基本数据类型通过“==”比较，其结果与第一点相同；</p><p>d.Integer对象的hash值为数值本身；</p><p><strong>为什么是-128-127?</strong></p><p>在 Integer 类中有一个静态内部类 IntegerCache，在 IntegerCache类中有一个 Integer 数组，用以缓存当数值范围为-128~127时的Integer 对象。</p><p><strong>九. 简单介绍一下java中的泛型，泛型擦除以及相关的概念。</strong></p><p>泛型是 Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p><p>在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><p>1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。</p><p>2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>3、泛型的类型参数可以有多个。</p><p>4、泛型的参数类型可以使用extends语句，例如<t extends="" superclass="">。习惯上称为“有界类型”。</t></p><p>5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(“java.lang.String”);</p><p><strong>泛型擦除以及相关的概念</strong></p><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</p><p><strong>类型擦除引起的问题及解决方法</strong></p><p>1、先检查，在编译，以及检查编译的对象和引用传递的问题</p><p>2、自动类型转换</p><p>3、类型擦除与多态的冲突和解决方法</p><p>4、泛型类型变量不能是基本数据类型</p><p>5、运行时类型查询</p><p>6、异常中使用泛型的问题</p><p>7、数组（这个不属于类型擦除引起的问题）</p><p>9、类型擦除后的冲突</p><p>10、泛型在静态方法和静态类中的问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;特别声明：&lt;/strong&gt;转载，文章出处：&lt;a href=&quot;https://github.com/GavinHwa/alibaba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/GavinHwa/alibaba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。&lt;/p&gt;
&lt;p&gt;答案持续更新中…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://charleywu.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>LinkedBlockingQueue-Clear原理</title>
    <link href="http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear%E5%8E%9F%E7%90%86/"/>
    <id>http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear原理/</id>
    <published>2017-11-21T10:18:50.000Z</published>
    <updated>2017-11-24T02:15:13.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。</p><a id="more"></a><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      queue.put(<span class="number">10</span>);</div><div class="line">      queue.put(<span class="number">20</span>);</div><div class="line">      queue.put(<span class="number">30</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClear</span><span class="params">()</span></span>&#123;</div><div class="line">    queue.clear();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建一个阻塞队列，然后进行清空；</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>LinkedBlockingQueue Clear()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Atomically removes all of the elements from this queue.</div><div class="line"> * The queue will be empty after this call returns.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">  fullyLock();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p, h = head; (p = h.next) != <span class="keyword">null</span>; h = p) &#123;</div><div class="line">      h.next = h;</div><div class="line">      p.item = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    head = last;</div><div class="line">    <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span></div><div class="line">    <span class="keyword">if</span> (count.getAndSet(<span class="number">0</span>) == capacity)</div><div class="line">      notFull.signal();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    fullyUnlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h3><h4 id="Step-1-新建队列："><a href="#Step-1-新建队列：" class="headerlink" title="Step-1 新建队列："></a>Step-1 新建队列：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp1.png" alt="Step1"></p><h4 id="Step-2-执行初始化语句Node-lt-E-gt-p-h-head"><a href="#Step-2-执行初始化语句Node-lt-E-gt-p-h-head" class="headerlink" title="Step-2 执行初始化语句Node&lt;E&gt; p, h = head;:"></a>Step-2 执行初始化语句<code>Node&lt;E&gt; p, h = head;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp2.png" alt="Step-2"></p><h4 id="Step-3-执行条件判断语句-p-h-next-null"><a href="#Step-3-执行条件判断语句-p-h-next-null" class="headerlink" title="Step-3 执行条件判断语句(p = h.next) != null;:"></a>Step-3 执行条件判断语句<code>(p = h.next) != null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp3.png" alt="Step-3"></p><h4 id="Step-4-执行循环体中h-next-h"><a href="#Step-4-执行循环体中h-next-h" class="headerlink" title="Step-4 执行循环体中h.next = h;:"></a>Step-4 执行循环体中<code>h.next = h;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp4.png" alt="Step-4"></p><h4 id="Step-5-执行循环体中p-item-null"><a href="#Step-5-执行循环体中p-item-null" class="headerlink" title="Step-5 执行循环体中p.item = null;:"></a>Step-5 执行循环体中<code>p.item = null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp5.png" alt="Step-5"></p><h4 id="Step-6-执行控制条件语句h-p"><a href="#Step-6-执行控制条件语句h-p" class="headerlink" title="Step-6 执行控制条件语句h = p:"></a>Step-6 执行控制条件语句<code>h = p</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp6.png" alt="Step-6"></p><h4 id="Step-7-执行循环体直至最后一个节点："><a href="#Step-7-执行循环体直至最后一个节点：" class="headerlink" title="Step-7 执行循环体直至最后一个节点："></a>Step-7 执行循环体直至最后一个节点：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp7.png" alt="Step-7"></p><h4 id="Step-8-执行语句head-last"><a href="#Step-8-执行语句head-last" class="headerlink" title="Step-8 执行语句head = last;:"></a>Step-8 执行语句<code>head = last;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp8.png" alt="Setp8"></p><p>将head、last都指向空节点，触发notFull条件，以便插入线程添加元素，至此队列的清空操作完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://charleywu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://charleywu.com/2017/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://charleywu.com/2017/08/03/数据库事务/</id>
    <published>2017-08-03T02:03:46.000Z</published>
    <updated>2017-11-23T10:05:47.666Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。</p><a id="more"></a><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 (ACID)"></a>事务的特性 (ACID)</h3><ul><li><p><strong>A (Atomacity)  原子性</strong></p><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>C (Consistency) 一致性</strong></p><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>I (Isolation) 隔离性</strong></p><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>D (Durability) 持久性</strong></p><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p><ul><li><p><strong>未提交读 (Read Uncommitted)</strong></p><p>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。Read Uncommitted允许脏读。</p></li><li><p><strong>已提交读 (Read Committed)</strong></p><p>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。Read Commited 不允许脏读，但会出现非重复读。</p></li><li><p><strong>可重复读 (Repeatable Read)</strong></p><p>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</p></li></ul><ul><li><p><strong>串行读 (Serializable)</strong></p><p>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。Serializable 不允许不一致现象的出现。</p><p>​</p></li></ul><p><em>几种隔离级别可能出现的异常场景:</em></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li><strong>脏读 (Dirty Read)：</strong>A 事务读到 B 事务未提交的修改。</li><li><strong>不可重复读 (NonRepeatable Read)：</strong>A 事务还没有结束时，B 事务也访问同一数据。在 A 事务的两次读取之间，由于 B 事务的修改，A 事务两次读到的数据可能是不一样的。</li><li><strong>幻读 (Phantom Read)：</strong>A 事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B 事务也修改这个表中的数据，这种修改是向表中插入一行新数据。操作 A 事务的用户发现表中出现了 B 事务插入的行，就好象发生了幻觉一样。</li></ul><p>MySQL 默认的级别是 REPEATABLE READ（可重复读），这表示在 MySQL 的默认情况下，“脏读”、“不可重复读”是不会发生的。这就需要在更新的时候进行必要的锁定（InnoDB 是采用行级锁的方式），从而保证一致性。需要注意的是 InnoDB 的行锁是通过给索引上的索引项加锁来实现的，这个特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p><p>我们数据库表是 InnoDB 引擎的表，而 MySQL 的 InnoDB 引擎是一个支持事务的引擎，其默认操作模式是 autocommit 自动提交模式。什么意思呢？除非我们显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://charleywu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://charleywu.com/2017/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://charleywu.com/2017/08/02/数据结构与算法/</id>
    <published>2017-08-02T01:28:38.000Z</published>
    <updated>2017-08-02T01:28:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程浅析</title>
    <link href="http://charleywu.com/2017/07/27/Java%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://charleywu.com/2017/07/27/Java线程浅析/</id>
    <published>2017-07-27T02:42:00.000Z</published>
    <updated>2017-11-23T10:07:04.491Z</updated>
    
    <content type="html"><![CDATA[<p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><h3 id="虚拟机线程状态-vs-操作系统线程状态"><a href="#虚拟机线程状态-vs-操作系统线程状态" class="headerlink" title="虚拟机线程状态 vs 操作系统线程状态"></a>虚拟机线程状态 vs 操作系统线程状态</h3><p>Java线程状态指的是虚拟机层面暴露给开发者使用的状态，由Thread.State类定义。底层由于操作系统的千差万别，各操作系统对于线程也有不同的状态，有可能操作系统线程多个状态对应一个Java线程状态；虚拟机的存在就是统一了底层的这些差别，让开发者不必关心这些问题。</p><h3 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h3><p>自JDK1.5开始，Java在Thread；且在给定时间点上，一个线程只能处于这6种状态中的一种。</p><ul><li><p><strong>NEW</strong></p><blockquote><p>Thread state for a thread which has not yet started.</p></blockquote></li></ul><ul><li><p><strong>RUNNABLE</strong></p><blockquote><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p></blockquote></li><li><p><strong>BOLCKED</strong></p><blockquote><p>Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling<code>Object.wait</code>.</p><p>​</p></blockquote></li><li><p><strong>WAITING</strong></p><blockquote><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ul><li><code>Object.wait</code> with no timeout</li><li><code>Thread.join</code> with no timeout</li><li><code>LockSupport.park</code></li></ul><p>A thread in the waiting state is waiting for another thread to perform a particular action. For example, a thread that has called <code>Object.wait()</code> on an object is waiting for another thread to call <code>Object.notify()</code> or <code>Object.notifyAll()</code> on that object. A thread that has called <code>Thread.join()</code> is waiting for a specified thread to terminate.</p><p>​</p></blockquote></li></ul><ul><li><p><strong>TIMED_WAITING</strong></p><blockquote><p>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:</p><ul><li><code>Thread.sleep</code></li></ul><ul><li><code>Object.wait</code> with timeout</li></ul><ul><li><code>Thread.join</code> with timeout</li></ul><ul><li><code>LockSupport.parkNanos</code></li></ul><ul><li><code>LockSupport.parkUntil</code></li></ul></blockquote></li></ul><ul><li><p><strong>TERMINATED</strong></p><blockquote><p>Thread state for a terminated thread. The thread has completed execution.</p></blockquote></li></ul><p><em>Oracle官方文档片段</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static enum Thread.State</div><div class="line">extends Enum&lt;Thread.State&gt;</div><div class="line">  </div><div class="line">A thread state. A thread can be in one of the following states:</div><div class="line">    NEW</div><div class="line">    A thread that has not yet started is in this state.</div><div class="line">    RUNNABLE</div><div class="line">    A thread executing in the Java virtual machine is in this state.</div><div class="line">    BLOCKED</div><div class="line">    A thread that is blocked waiting for a monitor lock is in this state.</div><div class="line">    WAITING</div><div class="line">    A thread that is waiting indefinitely for another thread to perform a particular action is in this state.</div><div class="line">    TIMED_WAITING</div><div class="line">    A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.</div><div class="line">    TERMINATED</div><div class="line">    A thread that has exited is in this state.</div><div class="line">      </div><div class="line">A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</div><div class="line"></div><div class="line">Since:</div><div class="line">1.5</div></pre></td></tr></table></figure><h3 id="Java线程状态迁移"><a href="#Java线程状态迁移" class="headerlink" title="Java线程状态迁移"></a>Java线程状态迁移</h3><p><img src="http://charleywucl.github.io/images/blog/thread/ThreadStateTransform.png" alt="ThreadStateTranform"></p><h3 id="Java线程常用方法"><a href="#Java线程常用方法" class="headerlink" title="Java线程常用方法"></a>Java线程常用方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://charleywu.com/tags/JAVA/"/>
    
  </entry>
  
</feed>
