<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TickTock Ideas</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charleywu.com/"/>
  <updated>2017-12-17T08:52:28.526Z</updated>
  <id>http://charleywu.com/</id>
  
  <author>
    <name>Charley Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM关键知识点图解</title>
    <link href="http://charleywu.com/2017/12/17/JVM%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE%E8%A7%A3/"/>
    <id>http://charleywu.com/2017/12/17/JVM关键知识点图解/</id>
    <published>2017-12-17T08:18:58.000Z</published>
    <updated>2017-12-17T08:52:28.526Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。</p><a id="more"></a><h3 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h3><p><img src="/jvm/JVM-虚拟机内存模型.png" alt="JVM-虚拟机内存模型"></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/jvm/JVM-类加载的过程.jpg" alt="JVM-类加载的过程"></p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><img src="/jvm/JVM-内存分配与回收策略.jpg" alt="JVM-内存分配与回收策略"></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="/jvm/JVM-垃圾回收算法.jpg" alt="JVM-垃圾回收算法"></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="/jvm/JVM-垃圾回收器.jpg" alt="JVM-垃圾回收器"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集了一下关于JVM关键知识点的思维导图，为防止丢失，故做一个简单的整理，方便查看。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPU占用过高问题排查</title>
    <link href="http://charleywu.com/2017/12/15/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://charleywu.com/2017/12/15/CPU占用过高问题排查/</id>
    <published>2017-12-15T03:13:51.000Z</published>
    <updated>2017-12-17T08:57:51.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载：</strong></p><p>看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。</p><a id="more"></a><h3 id="Step-1：找到CPU占用最高的进程"><a href="#Step-1：找到CPU占用最高的进程" class="headerlink" title="Step-1：找到CPU占用最高的进程"></a>Step-1：找到CPU占用最高的进程</h3><blockquote><p>$ top -c    //显示进程运行信息列表</p><p>$ P        //进程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="/Users/Charley/Desktop/step-1.png" alt="step-1"></p><p>上图中消耗CPU最高的进程号为<code>4150</code></p><h3 id="Step-2：找到进程中CPU消耗最高的线程"><a href="#Step-2：找到进程中CPU消耗最高的线程" class="headerlink" title="Step-2：找到进程中CPU消耗最高的线程"></a>Step-2：找到进程中CPU消耗最高的线程</h3><blockquote><p>$ top -Hp 4150    //显示一个进程的线程运行信息列表</p><p>$ P                //线程按照CPU使用率排序</p></blockquote><p><em>图例：</em></p><p><img src="/Users/Charley/Desktop/step-2.png" alt="step-2"></p><p>进程<code>4150</code>内，最耗CPU的线程为<code>4157</code></p><h3 id="Step-3：将线程ID转换为十六进制"><a href="#Step-3：将线程ID转换为十六进制" class="headerlink" title="Step-3：将线程ID转换为十六进制"></a>Step-3：将线程ID转换为十六进制</h3><blockquote><p>$ printf “%x\n” 4157    //结果为“103dn”</p></blockquote><p>Java堆栈里，线程id是用16进制表示的</p><h3 id="Step-4：查看堆栈中当前线程在做什么"><a href="#Step-4：查看堆栈中当前线程在做什么" class="headerlink" title="Step-4：查看堆栈中当前线程在做什么"></a>Step-4：查看堆栈中当前线程在做什么</h3><blockquote><p>$ jstack 4150 | grep ‘103dn’ -C5 –color</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到一篇文章关于CPU load100%问题的排查思路，故实操整理一遍。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Alibaba面试题</title>
    <link href="http://charleywu.com/2017/12/07/Alibaba%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://charleywu.com/2017/12/07/Alibaba面试题/</id>
    <published>2017-12-07T07:46:16.000Z</published>
    <updated>2017-12-07T08:18:20.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>特别声明：</strong>转载，文章出处：<a href="https://github.com/GavinHwa/alibaba" target="_blank" rel="external">https://github.com/GavinHwa/alibaba</a></p><p>无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。</p><p>答案持续更新中…</p><a id="more"></a><ol><li><p>HashMap和Hashtable的区别</p></li><li><p>实现一个保证迭代顺序的HashMap</p></li><li><p>说一说排序算法，稳定性，复杂度</p></li><li><p>说一说GC</p></li><li><p>可以保证的实习时长</p></li><li><p>职业规划</p><p>​</p></li></ol><p>（1）自我介绍。</p><p>（2）JVM如何加载一个类的过程，双亲委派模型中有哪些方法？</p><p>（3）HashMap如何实现的？</p><p>（4）HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</p><p>（5）HashMap和HashTable 区别，HashTable线程安全吗？</p><p>（6）进程间通信有哪几种方式？</p><p>（7）JVM分为哪些区，每一个区干吗的？</p><p>（8）JVM如何GC，新生代，老年代，持久代，都存储哪些东西？</p><p>（9）GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？</p><p>（10）快速排序，过程，复杂度？</p><p>（11）什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。</p><p>（12）TCP如何保证可靠传输？三次握手过程？</p><p>（13）TCP和UDP区别？</p><p>（14）滑动窗口算法？</p><p>（15）Linux下如何进行进程调度的？</p><p>（16）Linux下你常用的命令有哪些？</p><p>（17）操作系统什么情况下会死锁？</p><p>（18）常用的hash算法有哪些？</p><p>（19）什么是一致性哈希？</p><p>（20）如何理解分布式锁？</p><p>（21）数据库中的范式有哪些？</p><p>（22）数据库中的索引的结构？什么情况下适合建索引？</p><p>（23）Java中的NIO，BIO，AIO分别是什么？</p><p>（24）用什么工具调试程序？JConsole，用过吗？</p><p>（25）现在JVM中有一个线程挂起了，如何用工具查出原因？</p><p>（26）线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？</p><p>（27）同步和异步有什么区别？</p><p>（28）线程池用过吗？</p><p>（29）如何创建单例模式？说了双重检查，他说不是线程安全的。如何高效的创建一个线程安全的单例？</p><p>（30）concurrent包下面，都用过什么？</p><p>（31）常用的数据库有哪些？redis用过吗？</p><p>（32）了解hadoop吗？说说hadoop的组件有哪些？hdfs，hive,hbase,zookeeper。说下mapreduce编程模型。</p><p>（33）你知道的开源协议有哪些？</p><p>（34）你知道的开源软件有哪些？</p><p>（35）你最近在看的书有哪些？</p><p>（36）你有什么问题要问我吗？</p><p>（37）了解哪些设计模式？说说都用过哪些设计模式</p><p>（38）如何判断一个单链表是否有环？</p><p>（39）操作系统如何进行分页调度？</p><p>（40）匿名内部类是什么？如何访问在其外面定义的变量？</p><p>1）自我介绍，做过什么项目。</p><p>（2）java虚拟机的区域如何划分，每一个区的动能，这一块自由发挥。</p><p>（3）双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？</p><p>（4）有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？</p><p>（5）HashMap的结构，get()，put()是如何实现的？HashMap有哪些问题？</p><p>（6）ConcurrentHashMap的get()，put()，又是如何实现的？ConcurrentHashMap有哪些问题？ ConcurrentHashMap的锁是读锁还是写锁？</p><p>（7） HashMap与HashTable的区别</p><p>（8）sleep()和wait()分别是哪个类的方法，有什么区别？synchronized底层如何实现的？用在代码块和方法上有什么区别？</p><p>（9）什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？</p><p>（10）什么是死锁？JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？这一块问的很多….问的我懵了. 因为并没有实际操作过 = =</p><p>（11）查看jvm虚拟机里面堆、线程的信息，你用过什么命令？我只用过图形界面VisualVM。。。</p><p>（12）垃圾回收算法有哪些？CMS知道吗？如何工作的？</p><p>（13）数据库中什么是事务？事务的隔离级别？事务的四个特性？什么是脏读，幻读，不可重复读？</p><p>（14）数据库索引的结构有哪些？我说B树和B+树，他说只有这两个吗。我又说全文倒排索引。然后介绍B+树的结构。</p><p>（15）数据库中的分页查询语句怎么写？</p><p>（16）什么是一致性哈希？用来解决什么问题？</p><p>（17）Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</p><p>（18）项目中用到redis，为什么选用redis，了解其他NoSQL数据库吗？在你的项目中是如何运用redis的？key是什么，value是什么？</p><p>（19）归并排序的过程？时间复杂度？空间复杂度？</p><p>（20）你平常用什么排序？快速排序。说说在那些场景下适用，哪些场景下不适用。</p><p>（21）你在项目中做什么？因为我用到Solr，他就问我Solr是如何工作的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;特别声明：&lt;/strong&gt;转载，文章出处：&lt;a href=&quot;https://github.com/GavinHwa/alibaba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/GavinHwa/alibaba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无意中在网上看到一篇关于阿里面试的文章，感觉不错，特转载。涉及很多java底层实现原理，jvm相关知识，就算不面试，对于深入理解java也是不错的选择。&lt;/p&gt;
&lt;p&gt;答案持续更新中…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://charleywu.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>LinkedBlockingQueue-Clear原理</title>
    <link href="http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear%E5%8E%9F%E7%90%86/"/>
    <id>http://charleywu.com/2017/11/21/LinkedBlockingQueue-Clear原理/</id>
    <published>2017-11-21T10:18:50.000Z</published>
    <updated>2017-11-24T02:15:13.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。</p><a id="more"></a><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">  <span class="meta">@Before</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      queue.put(<span class="number">10</span>);</div><div class="line">      queue.put(<span class="number">20</span>);</div><div class="line">      queue.put(<span class="number">30</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClear</span><span class="params">()</span></span>&#123;</div><div class="line">    queue.clear();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建一个阻塞队列，然后进行清空；</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>LinkedBlockingQueue Clear()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Atomically removes all of the elements from this queue.</div><div class="line"> * The queue will be empty after this call returns.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">  fullyLock();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p, h = head; (p = h.next) != <span class="keyword">null</span>; h = p) &#123;</div><div class="line">      h.next = h;</div><div class="line">      p.item = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    head = last;</div><div class="line">    <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span></div><div class="line">    <span class="keyword">if</span> (count.getAndSet(<span class="number">0</span>) == capacity)</div><div class="line">      notFull.signal();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    fullyUnlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h3><h4 id="Step-1-新建队列："><a href="#Step-1-新建队列：" class="headerlink" title="Step-1 新建队列："></a>Step-1 新建队列：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp1.png" alt="Step1"></p><h4 id="Step-2-执行初始化语句Node-lt-E-gt-p-h-head"><a href="#Step-2-执行初始化语句Node-lt-E-gt-p-h-head" class="headerlink" title="Step-2 执行初始化语句Node&lt;E&gt; p, h = head;:"></a>Step-2 执行初始化语句<code>Node&lt;E&gt; p, h = head;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp2.png" alt="Step-2"></p><h4 id="Step-3-执行条件判断语句-p-h-next-null"><a href="#Step-3-执行条件判断语句-p-h-next-null" class="headerlink" title="Step-3 执行条件判断语句(p = h.next) != null;:"></a>Step-3 执行条件判断语句<code>(p = h.next) != null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp3.png" alt="Step-3"></p><h4 id="Step-4-执行循环体中h-next-h"><a href="#Step-4-执行循环体中h-next-h" class="headerlink" title="Step-4 执行循环体中h.next = h;:"></a>Step-4 执行循环体中<code>h.next = h;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp4.png" alt="Step-4"></p><h4 id="Step-5-执行循环体中p-item-null"><a href="#Step-5-执行循环体中p-item-null" class="headerlink" title="Step-5 执行循环体中p.item = null;:"></a>Step-5 执行循环体中<code>p.item = null;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp5.png" alt="Step-5"></p><h4 id="Step-6-执行控制条件语句h-p"><a href="#Step-6-执行控制条件语句h-p" class="headerlink" title="Step-6 执行控制条件语句h = p:"></a>Step-6 执行控制条件语句<code>h = p</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp6.png" alt="Step-6"></p><h4 id="Step-7-执行循环体直至最后一个节点："><a href="#Step-7-执行循环体直至最后一个节点：" class="headerlink" title="Step-7 执行循环体直至最后一个节点："></a>Step-7 执行循环体直至最后一个节点：</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp7.png" alt="Step-7"></p><h4 id="Step-8-执行语句head-last"><a href="#Step-8-执行语句head-last" class="headerlink" title="Step-8 执行语句head = last;:"></a>Step-8 执行语句<code>head = last;</code>:</h4><p><img src="https://charleywucl.github.io/images/blog/queue/LinkedBlockingQueue-clear-setp8.png" alt="Setp8"></p><p>将head、last都指向空节点，触发notFull条件，以便插入线程添加元素，至此队列的清空操作完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文意在通过图形化的形式展示LinkedBlockingQueue在Clear操作时数据结构的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://charleywu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://charleywu.com/2017/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://charleywu.com/2017/08/03/数据库事务/</id>
    <published>2017-08-03T02:03:46.000Z</published>
    <updated>2017-11-23T10:05:47.666Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。</p><a id="more"></a><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 (ACID)"></a>事务的特性 (ACID)</h3><ul><li><p><strong>A (Atomacity)  原子性</strong></p><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>C (Consistency) 一致性</strong></p><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>I (Isolation) 隔离性</strong></p><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>D (Durability) 持久性</strong></p><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p><ul><li><p><strong>未提交读 (Read Uncommitted)</strong></p><p>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。Read Uncommitted允许脏读。</p></li><li><p><strong>已提交读 (Read Committed)</strong></p><p>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。Read Commited 不允许脏读，但会出现非重复读。</p></li><li><p><strong>可重复读 (Repeatable Read)</strong></p><p>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</p></li></ul><ul><li><p><strong>串行读 (Serializable)</strong></p><p>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。Serializable 不允许不一致现象的出现。</p><p>​</p></li></ul><p><em>几种隔离级别可能出现的异常场景:</em></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li><strong>脏读 (Dirty Read)：</strong>A 事务读到 B 事务未提交的修改。</li><li><strong>不可重复读 (NonRepeatable Read)：</strong>A 事务还没有结束时，B 事务也访问同一数据。在 A 事务的两次读取之间，由于 B 事务的修改，A 事务两次读到的数据可能是不一样的。</li><li><strong>幻读 (Phantom Read)：</strong>A 事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B 事务也修改这个表中的数据，这种修改是向表中插入一行新数据。操作 A 事务的用户发现表中出现了 B 事务插入的行，就好象发生了幻觉一样。</li></ul><p>MySQL 默认的级别是 REPEATABLE READ（可重复读），这表示在 MySQL 的默认情况下，“脏读”、“不可重复读”是不会发生的。这就需要在更新的时候进行必要的锁定（InnoDB 是采用行级锁的方式），从而保证一致性。需要注意的是 InnoDB 的行锁是通过给索引上的索引项加锁来实现的，这个特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p><p>我们数据库表是 InnoDB 引擎的表，而 MySQL 的 InnoDB 引擎是一个支持事务的引擎，其默认操作模式是 autocommit 自动提交模式。什么意思呢？除非我们显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章对事务的特性以及数据库事务的隔离级别做了简单的归纳总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://charleywu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://charleywu.com/2017/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://charleywu.com/2017/08/02/数据结构与算法/</id>
    <published>2017-08-02T01:28:38.000Z</published>
    <updated>2017-08-02T01:28:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程浅析</title>
    <link href="http://charleywu.com/2017/07/27/Java%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://charleywu.com/2017/07/27/Java线程浅析/</id>
    <published>2017-07-27T02:42:00.000Z</published>
    <updated>2017-11-23T10:07:04.491Z</updated>
    
    <content type="html"><![CDATA[<p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。</p><h3 id="虚拟机线程状态-vs-操作系统线程状态"><a href="#虚拟机线程状态-vs-操作系统线程状态" class="headerlink" title="虚拟机线程状态 vs 操作系统线程状态"></a>虚拟机线程状态 vs 操作系统线程状态</h3><p>Java线程状态指的是虚拟机层面暴露给开发者使用的状态，由Thread.State类定义。底层由于操作系统的千差万别，各操作系统对于线程也有不同的状态，有可能操作系统线程多个状态对应一个Java线程状态；虚拟机的存在就是统一了底层的这些差别，让开发者不必关心这些问题。</p><h3 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h3><p>自JDK1.5开始，Java在Thread；且在给定时间点上，一个线程只能处于这6种状态中的一种。</p><ul><li><p><strong>NEW</strong></p><blockquote><p>Thread state for a thread which has not yet started.</p></blockquote></li></ul><ul><li><p><strong>RUNNABLE</strong></p><blockquote><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p></blockquote></li><li><p><strong>BOLCKED</strong></p><blockquote><p>Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling<code>Object.wait</code>.</p><p>​</p></blockquote></li><li><p><strong>WAITING</strong></p><blockquote><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ul><li><code>Object.wait</code> with no timeout</li><li><code>Thread.join</code> with no timeout</li><li><code>LockSupport.park</code></li></ul><p>A thread in the waiting state is waiting for another thread to perform a particular action. For example, a thread that has called <code>Object.wait()</code> on an object is waiting for another thread to call <code>Object.notify()</code> or <code>Object.notifyAll()</code> on that object. A thread that has called <code>Thread.join()</code> is waiting for a specified thread to terminate.</p><p>​</p></blockquote></li></ul><ul><li><p><strong>TIMED_WAITING</strong></p><blockquote><p>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:</p><ul><li><code>Thread.sleep</code></li></ul><ul><li><code>Object.wait</code> with timeout</li></ul><ul><li><code>Thread.join</code> with timeout</li></ul><ul><li><code>LockSupport.parkNanos</code></li></ul><ul><li><code>LockSupport.parkUntil</code></li></ul></blockquote></li></ul><ul><li><p><strong>TERMINATED</strong></p><blockquote><p>Thread state for a terminated thread. The thread has completed execution.</p></blockquote></li></ul><p><em>Oracle官方文档片段</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static enum Thread.State</div><div class="line">extends Enum&lt;Thread.State&gt;</div><div class="line">  </div><div class="line">A thread state. A thread can be in one of the following states:</div><div class="line">    NEW</div><div class="line">    A thread that has not yet started is in this state.</div><div class="line">    RUNNABLE</div><div class="line">    A thread executing in the Java virtual machine is in this state.</div><div class="line">    BLOCKED</div><div class="line">    A thread that is blocked waiting for a monitor lock is in this state.</div><div class="line">    WAITING</div><div class="line">    A thread that is waiting indefinitely for another thread to perform a particular action is in this state.</div><div class="line">    TIMED_WAITING</div><div class="line">    A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.</div><div class="line">    TERMINATED</div><div class="line">    A thread that has exited is in this state.</div><div class="line">      </div><div class="line">A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</div><div class="line"></div><div class="line">Since:</div><div class="line">1.5</div></pre></td></tr></table></figure><h3 id="Java线程状态迁移"><a href="#Java线程状态迁移" class="headerlink" title="Java线程状态迁移"></a>Java线程状态迁移</h3><p><img src="http://charleywucl.github.io/images/blog/thread/ThreadStateTransform.png" alt="ThreadStateTranform"></p><h3 id="Java线程常用方法"><a href="#Java线程常用方法" class="headerlink" title="Java线程常用方法"></a>Java线程常用方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在回顾Java线程相关知识点时，发现互联网上很多不负责任的文章将Java线程状态与操作系统线程状态混为一谈，极为混乱，极大的误导了读者；故在此做一个详细的梳理；也望读者不要轻易相信互联网上的文章，最好亲自查证。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://charleywu.com/tags/JAVA/"/>
    
  </entry>
  
</feed>
